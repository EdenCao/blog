<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[N 数之和]]></title>
    <url>%2Fblog%2F2019%2F05%2F11%2FN-Number-Sum%2F</url>
    <content type="text"><![CDATA[最近在刷 leetcode 的时候看到了一些有意思的题目所以想总结一下，这次主要整理的是 N 数之和系列，希望能把自己做题时候的过程介绍清楚。两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]这里面最重要的话实际上是你可以假设每种输入只会对应一个答案,这意味着我们可以不考虑重复的情况。如果没有这句话的话，我们可以假设有以下数组：1nums = [-1, -1, 1, 2, -2]; target = 0那么答案应该是：1234result = [ [-1, 1], [-2, 2]]需要注意的是这里面存在两个 -1，这意味如果我们用暴力枚举的话会存在以下结果1234567891011[-1, -1][-1, 1][-1, 2][-1, -2][-1, -1][-1, 1][-1, 2][-1, -2][1, 2][1, -2][2, -2]我们可以看到遍历中会有两个 [-1, 1], 因此需要去重但是这里只需要考虑只有一个返回值，因此只需要找到第一个结果返回就可以了。1234567891011// 枚举法export function twoSum(nums: number[], target: number): [number, number] | null&#123; let n = nums.length; for (let i = 0; i &lt; n - 1; i++) &#123; for(let j = i + 1; j &lt; n; j ++) &#123; if (nums[i] + nums[j] === target) return [nums[i], nums[j]] &#125; &#125; return null&#125;另外需要注意的是最外层循环的判断条件是 i &lt; n - 1, 因为这里一共要返回两个值，因此最外层循环最多只能到倒数第二个数。以上时间复杂度为 O(n^2)除此之外，我们可以以空间换时间的方法, liyong map 记录 value -&gt; index 的映射1234567891011121314export function twoSum(nums: number[], target: number): [number, number] | null &#123; let n = nums.length; let indexes = new Map&lt;number, number&gt;(); for(let i = 0; i &lt; n; i ++) &#123; let diff = target - nums[i]; if (indexes.get(diff)) &#123; return [indexes.get(diff)!, i]; &#125; else &#123; indexes.set(nums[i], i); &#125; &#125; return null;&#125;可以看到，上面再便利的过程中会存储 value -&gt; index，的映射，每次新遇到一个值的时候会首先判断差值是否存在，如果存在的话那么直接返回对应的 index，如果不存在则存入 Map 中继续查找。上述方法时间复杂度为 O(n), 空间复杂度为 O(n)未完待续….]]></content>
      <tags>
        <tag>leetcode, algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你知道的JS原型链（上）--对象与原型]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2FYou-Know-The-JS-Prototype-Chain-(top)---Objects-And-Prototypes%2F</url>
    <content type="text"><![CDATA[你知道的JS原型链–对象与原型最近一直在以忙为借口犯懒，到了清明节终于捱不过去了，所以还是准备写一篇文章来总结一下。最近开发的一个项目涉及到一些关于es6继承的问题。得益于JavaScript强大的原型机制，我们可以很轻易的模仿出类的特性，当然由于是基于原型实现的class语法糖，所以我们可以做出一些特别骚气的操作，比如动态继承。例如1234567891011121314151617181920class A &#123; constructor()&#123; console.log('this is A'); &#125;&#125;// class factoryfunction InheritMaker(constructor)&#123; return class B extends constructor &#123; constructor()&#123; super(); console.log('this is B'); &#125; &#125;&#125;const a = new A(); // this is Aconst B = InheritMaker(A);const b = new B(); // this is A; this is B说实话，我一直在思考这种方式到底是不是违反了类的初衷。类是静态的，但是我们在 JavaScript中可以在运行时动态选择继承，这使得类的行为变得不确定: 我无法知道我的类到底会实现什么样子的功能，只用运行时才知道。这种见鬼的实现方式在Java中绝对会报错报到死，但是在JavaScript中却可以平稳运行。说了这么多，这种灵活不失骚气的实现方式还是得益于JavaScript中强大的原型机制。接下来，我希望来说清楚JavaScript中的原型到底是怎么回事，以及抛砖引玉的对于es6的class实现进行一些粗浅的探讨。对象与原型我最一开始接触JavaScript的时候不知道什么是原型，把它和对象当作两个概念来看待。我们都知道，一个类new出来的实例是一个对象。我们来看下EcmaScript对于对象的定义:无序属性的集合，其属性可以包含基本值，对象或者函数原型就是无需属性的集合，原型就是对象,原型就是实例下面让我们来抛开es6谈一谈对象与原型。我们都知道，对象是我们用class ‘new’出来的，例如我们想实现创建两个人，张三和李四，他们都拥有相同的属性，但是属性的值不同，所以我们将他们归为一个‘类’，在某些静态语言中大致长这样：123456789class People &#123; constructor(string name, int age) &#123; this.name = name; this.age = age; &#125;&#125;const zhangsan = new People('张三'， 12)；const lisi = new People('李四', 14);这样两个人就创建好了。但是JavaScript没有类的概念怎么破？下面用es5实现了同样的 效果：1234567function Peole(name, age) &#123; this.name = name; this.age = age;&#125;var zhangsan = new People('张三', 12);var lisi = new People('李四'， 14);上面创建了一个构造函数，实现了相同的效果。对于JavaScript来说，People是一个实例，它的构造函数是Function,因此它拥有__proto__,又是(构造)函数，所以拥有prototype，值得说明的一点是只有函数拥有prototype。那么prototype与__proto__又有什么区别呢？prototype &amp; protoJavaScript中有两个指针，prototype与__proto__，我在初学的时候一直对于这两个指针一直十分困惑，现在我希望可以解释清楚这些事情。对于People构造函数来说，它在被创建的时候拥有prototype属性，prototype的constructor指向它本身：如果用一种不太准确但容易理解的方式来解释，prototype才是People的类，上面拥有People所定义的一切方法，例如我们举个例子：12345678910class People &#123; constructor(name, age)&#123; this.name = name; this.age = age; &#125; changeName(newName)&#123; this.name = newName; &#125;&#125;我们在上面多声明了一个方法changeName,因此上面的图改为：这就是prototype但是我们也说了People不仅仅是个构造函数，它还是Function的实例，对于一个实例来说，它需要知道创建它的类是什么。注意这里非常容易糊涂：prototype指向的是它作为构造函数的类_proto_指向的是创建它的类其实这也非常容易理解，因为对于JavaScript来说，函数也是一个对象。也就是说函数也是被‘new’出来的。创建它的类是Function就是下面的这个Function:1const People = new Function();因此上面的图可以更改为：同样的，Function类的构造函数也是一个函数。。所以Function构造函数的prototype指向Function类,而它的__proto__也指向它的类：因此你可以试一下：1Function.prototype === Function.__proto__; // true我们刚才也说过了，prototype 也是一个对象，也是被’new‘出来的，因为是对象，所以创造它的构造函数是Object,因此上图可以更改为：因此就出现了一个问题，创建Object的类是个毛？说的再玄幻一点就是创建对象的是个什么玩应？是null从无到有。小结因此原型的本质可以概括为：JavaScript中的类也是个对象当然这不太准确，我会在下节做阐述，先这么理解就好。]]></content>
  </entry>
  <entry>
    <title><![CDATA[VScode 配置清单]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2FVScode-Configuration-List%2F</url>
    <content type="text"><![CDATA[VS code 配置文件我一直觉得所谓的编辑器之争与语言之争以及编程风格之争是一件很无聊的事情，一个优秀的工程师需要学会在合适的地方选择合适的工具或语言帮助自己完成任务，而几个同样优秀的编程风格之间最重要的是有一个统一的标准。或许是我见识浅薄，但我坚持认为只有拥有这样的认知标准才能称为一个优秀的工程师，而不是成为语言和工具的奴隶。VS code 确实对我来说拥有无与伦比的优势，相比于插件丰富的 Atom 来说，vs code 内置的终端确实更对我的胃口，经过简单的配置就可以使用，在这一点上的确对我很有吸引力。vscode配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162&#123; "gitlens.advanced.messages": &#123; "suppressCommitHasNoPreviousCommitWarning": false, "suppressCommitNotFoundWarning": false, "suppressFileNotUnderSourceControlWarning": false, "suppressGitVersionWarning": false, "suppressLineUncommittedWarning": false, "suppressNoRepositoryWarning": false, "suppressUpdateNotice": false, "suppressWelcomeNotice": true &#125;, // 开启vscode-icons主题 "workbench.iconTheme": "vscode-icons", // 个人感觉颜色比较鲜艳的主题 "workbench.colorTheme": "One Dark Pro Vivid", // 我在这里对自动保存设置了一个延迟 "files.autoSave": "afterDelay", "git.confirmSync": false, "editor.formatOnType": true, // 在这里主要做了对vue语言的支持 "files.associations": &#123; "*.vue": "vue", "*.js": "javascript", "*.md": "markdown" &#125;, // 将一些不必要的搜索范围去掉 "search.exclude": &#123; "**/node_modules": true, "**/bower_components": true, "**/dist": true, "**/.git": true &#125;, // 主要是设置选中范围是尖角还是圆角，没啥必要 "editor.roundedSelection": false, // 因为有时后需要查看.git的设置，所以将.git加入显示范围 "files.exclude": &#123; "**/.git": false, "**/.svn": true, "**/.hg": true, "**/CVS": true, "**/.DS_Store": true &#125;, // 这里主要是设置emmet对于vue的支持 "emmet.syntaxProfiles": &#123; "vue": "html", "vue-html": "html", &#125;, // 同上 "emmet.includeLanguages": &#123; "vue-html": "html", "vue": "html", "javascript": "javascriptreact" &#125;, // 我比较喜欢用Enter换行，所以emmet提示设置只用tab选择 "emmet.triggerExpansionOnTab": true, // Fira Code是我最喜欢的字体，下面会介绍原因 "editor.fontFamily": "Fira Code, Menlo, Monaco, 'Courier New', monospace", // 将行高设置高一点会显得很高大上且舒服 "editor.lineHeight": 24, // 缩进规则，主要看公司要求和个人习惯 "[javascript]": &#123; "editor.insertSpaces": true, "editor.tabSize": 4 &#125;, // 因为我没怎么用过打开的编辑器，都是用cmd+p进行跳转。。 "explorer.openEditors.visible": 0, // 主要是一些css代码规范的问题，禁用important "css.lint.important": "error", "less.lint.important": "error", "scss.lint.important": "error", // 设置eslint对于vue的支持 "eslint.validate": [ "javascript", "javascriptreact", "html", "vue" ], // 我不是很喜欢小地图。。 "editor.minimap.enabled": false, // Fira Code 支持需要开启 "editor.fontLigatures": true, "editor.tabSize": 4, // 对于一些比较头痛的地方禁用emmet "emmet.excludeLanguages": [ "markdown", "less", "pug" ], // 设置代码换行大小 "editor.rulers": [ 80, 120 ], "todohighlight.include": [ "**/*.js", "**/*.jsx", "**/*.ts", "**/*.tsx", "**/*.html", "**/*.php", "**/*.css", "**/*.scss", "**/*.less", "**/*.vue" ], // 一个给文件加注释头的插件。。 "topper.headerTemplates": [ &#123; "defaultCStyled": &#123; "headerBegin": "/**", "headerPrefix": "*", "headerEnd": "*/", "template": [ "$&#123;headerBegin&#125;", "$&#123;headerPrefix&#125; $&#123;fileName&#125;", "$&#123;headerPrefix&#125; @author $&#123;author&#125;", "$&#123;headerPrefix&#125; @description $&#123;description&#125;", "$&#123;headerPrefix&#125; @created $&#123;createdDate&#125;", "$&#123;headerPrefix&#125; @copyright $&#123;copyright&#125;", "$&#123;headerPrefix&#125; @last-modified $&#123;lastModifiedDate&#125;", "$&#123;headerEnd&#125;" ] &#125; &#125;, &#123; "python": &#123; "headerBegin": "#", "headerPrefix": "#", "headerEnd": "#", "template": [ "$&#123;headerBegin&#125;", "$&#123;headerPrefix&#125; $&#123;fileName&#125;", "$&#123;headerPrefix&#125; @author $&#123;author&#125;", "$&#123;headerPrefix&#125; @description $&#123;description&#125;", "$&#123;headerPrefix&#125; @created $&#123;createdDate&#125;", "$&#123;headerPrefix&#125; @last-modified $&#123;lastModifiedDate&#125;", "$&#123;headerEnd&#125;" ] &#125; &#125; ], "topper.customTemplateParameters": [ &#123; "personalProfile": &#123; "author": "yungcho", "website": "", "copyright": "None \n None", "license": "None", "email": "yungcho@foxmail.com" &#125; &#125;, &#123; "officeProfile": &#123; "author": "Cao Yong", "department": "PGC", "email": "caoyong@bytedance.com" &#125; &#125; ], "git.autofetch": true, "workbench.activityBar.visible": true,&#125;字体介绍一个非常漂亮的连字体，专为程序员设计。具体不再赘述，详细可以查看 fira code 的 github插件Auto Close TagAuto Close Tag 可以帮助我们自动闭合标签，并且可以帮我们检查标签是否完备，这在使用Vue、React组件式开发的过程中可以帮助我们节省大量的时间。Auto Rename Tag与 Auto Close Tag 是一对，可以在我们修改标签的时候自动帮助我们修改一对。Beautify一个自动格式化软件Bracket Pair Colorizer一个自动给括号上不同颜色的插件，妈妈再也不怕我面对括号嵌套了。EditorConfig VS Code Snippet项目文件中的.editorconfig文件，加上这个插件就能自动读取了。ESLint一个添加vscode对于eslint支持的插件，加上以后不需要命令行就可以直接在编辑器中标识不符合规则的部分。filesize一个可以自动标识文件大小的小插件Git History一个很方便的查看git历史记录的插件GitLens一个可以看到当前代码提交记录的插件HTML CSS SUPPORT代码补全工具HTML SnippetsHTML的snippet插件### One Dark Pro很漂亮的vscode主题，再也不羡慕Atom了Path Intellisense自动路径提示### Regex Previewer一个写完正则就可以直接测试的插件TODO Highlight一个TODO LIST的插件Veturvue官方推荐的插件，可以代码提示等功能vscode-icons很漂亮且很实用的图标插件，帮助我们区分不同类型。]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于 ES Class 继承中的二三事（一）(你知道的原型链下)]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2FTwo-Or-Three-Things-About-ES-Class-Inheritance-(1)-(you-Know-Under-The-Prototype-Chain)%2F</url>
    <content type="text"><![CDATA[距离上已经写完了好长时间了，现在感觉对于 ES6 Class 有了一些新的理解。如果对于 JavaScript 中的原型机制还不太了解，可以帮我指正一下我写的这篇文章：https://www.jianshu.com/p/866657da6b7e其实上里面有一些概念是错误的：JS 中的 Class 是一个对象。本质上来说，如果将对象比喻成是一栋楼的话，Class 就是楼的设计图。这两者是不能混淆的，区别在于 JavaScript 使用原型来模拟类似于面向对象编程语言的一些行为，因此才会出现类似于“沿着原型寻方法” 或者 “遮蔽”这样的特性。实际上实现继承的方式有很多，《JavaScript 高级程序设计》上面已经介绍的很详细了，因此在这里不再赘述。不过如果你读过类属于 Vue / React 这种类库的源码的话就会发现，他们的核心代码还是在使用 Prototype 上面挂方法的方式来实现的（Monkey Patch）。如果你是用 ES Class 去实现一些比较复杂的 Class 的话就会发现，ES6 Class 实际上还是不适合去写一些特别复杂的类（尤其是类似于 Vue 这种）。如果你拥抱 ES6 Class 的话，就完全拥抱，如果你不喜欢这种方式，就完全不要用，这对于团队风格的统一、代码的实现方式以及日后维护都有着难以谚语的好处。继承的方式有很多种，写 React 组件采用的是组合式继承，Vue 则是提供了官方的 mixins。在标准 ES6 出现之前，我们都是在通过手动的方式来模拟继承的方式。现在，为了拥抱新的标准，我们会使用类似于 Babel 或者 shim 的方式来使用一些语法的新特性。但如果看过 Babel 的具体实现就会发现，继承实际上还是基于原型实现的。具体来说是把实例属性挂到对象上，然后 class 方法放到原型上。## 关于 bind如果你通读过类库 React 的官方文档的话，一定会记得 React 推荐你使用组合的方式来实现继承，而不是 Inheritance。这里附上原文地址：Composition vs Inheritance – React一个经常非常常见的问题是 this 丢失的问题，为此我们需要在 React 组件中这样写：是因为 method 方法在传递引用的过程中 this 丢失了，因此我们需要手动将远行方法绑定到实例上面。Bind 方法返回一个指定 this 的新函数，由于方法会先一步挂到 class 上面，因此右侧的 method 指的是原型上的 method 方法，这句话在实例上面创建了一个 method 属性，此属性保持着对于绑定 this 的 method 函数的引用。同样的写法还有如下两种：property method- 在使用的时候绑定：这三种使用方式会造成什么问题？第一种会在实例上面创建一个实例属性。第二种方法实际上会被编译到 constructor 当中, 类似于这样：我们在使用类继承的时候经常需要重载父类的函数，在 JavaScript 当中是通过遮蔽实现的。但是如果你在父类中使用了这种属性函数的方法，由于原型上的方法会先一步挂在到原型上，后一步 super 才会执行，结果是你的遮蔽是失效的。即使你在构造函数中手动绑定了 this 指向，也无法在函数内部通过 super.method 实现访问父类方法，因为这个方法并不存在在父类的原型上面。第三种方式实在使用的时候绑定：但是 bind 函数被执行后会返回一个新的函数，这会造成每次 render 函数执行时会重新创建一个新的函数传递给自组件，props 改变，可能造成不必要的子组件重新渲染。实际上这些问题不仅仅在使用 react 的时候才会出现，如果你大量依赖于继承去实现你自己的类库的话，很容易碰到上述问题。不过我在 github 上面找到了一个很有意思的解决方案：Autobind:GitHub - andreypopp/autobind-decorator: Decorator to automatically bind methods to class instances因为实际上是创建了一个 getter 的闭包函数来存储 bind 的fn，因次只有在第一次访问的时候会绑定 this，剩下的访问的都是同一个函数，从而解决了多次渲染的问题。但这个方案也不是尽善尽美，我目前主要遇到了两个问题：实际上使用 decorator 去实现，但是高阶组件可能会有一些问题：如果你受过阮老师的教诲的话，他在博客中曾经提到过 react-redux 实际上是一个装饰器工厂，你可以如此使用：12@connect(...)class Component extends React.Component&lt;any, any&gt; &#123;&#125;不过我现在没有找到这句话，可能已经被其他大神纠正了。在这种装饰器里面是无法使用另一个装饰器的。而且 react 为了避免 bind 污染子属性的问题，使用组合的方式来实现继承，因此你在写高阶组件的时候实际上是这么写的实际上返回的是一个全新的组件，因此高阶组件 connect 到底属不属于 decorator 需要另作讨论。mixins另外就是在使用 mixins 的时候，可能会出发 autobind 的 getter 导致绑定到错误的对象上面。如果你是用 autobind 的话，大概需要注意如上两个问题。实际上，就我个人而言，还是倾向于使用 bind 来解决 this 指向问题，不仅仅因为机制简单易懂，而且可以避免很多类似于 autobind 或者 property function 的问题，并且在子类中可以正确的使用 super.method 访问父类的方法。但如果你像我一样同样青睐这种方式的话，要注意一下：只在必要的地方使用 bind 以保证 this 的正确指向（因为会存在污染子类的问题），一般情况下，需要 bind 的情况只发生在需要传递函数引用的时候]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript语言精粹中的坑]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2FThe-Pit-Of-The-JavaScript-Language%2F</url>
    <content type="text"><![CDATA[2017-12-20更新：更新了以往表达不清楚的部分，为三个版本不同的地方添加上了注释附上了图书版次信息以供查询Javascript语言精粹第3章 对象原型1234567if (typeof Object.beget !== 'function')&#123; // 注意这里检查是否存在beget函数 Object.create = function(o) &#123; // 而这里则是给Object添加了create方法 var F = function () &#123;&#125;; F.prototype = o; return new F(); &#125;&#125;这个函数旨在为Object增加一个create方法，这个方法创建一个使用原对象作为其原型的新对象。我不明白的是为什么检查beget是否是一个函数（即是否已经存在），而下面则没有用到beget函数（而是在Object上面添加了create方法？）直接上结论：这应该是一个印刷错误这块应该是有两个版本：这个是英文原版1234567if( typeof Object.beget !== 'function' )&#123; // 注意这里是检查beget是否存在 Object.beget = function(o)&#123; // 而这里同样是添加beget方法 var F =new Function()&#123;&#125;; F.prototype = o; return new F(); &#125;&#125;这个是Safari Books Online上面的版本1234567if (typeof Object.create !== 'function') &#123; // 注意这里检查create方法是否存在 Object.create = function (o) &#123; // 而这里是添加的create方法 var F = function () &#123;&#125;; F.prototype = o; return new F(); &#125;;&#125;注意：在此书新版本中，不推荐使用new关键词，而是选择使用函数表达式的方法声明函数。这里附上图书版次信息,以供遇到同样的朋友参考Javacript语言精粹（Crockford,D.）电子工业出版社 2012.9ISBN: 978-7-121-17740-8印次：2017.04 第13次印刷感谢Brian Duncan回答了这部分关于new的相关问题。另外，在javascript中，new关键字必须与函数一同工作。例如1var a = new Array();这里a是一个数组，typeof a == &#39;Object&#39;,而typeof Array == &#39;function&#39;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[永不落伍的大前端]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2FThe-Big-Front-End-That-Never-Goes-Out-Of-Style%2F</url>
    <content type="text"><![CDATA[一直想把自己了解到的前端知识体系总结一下。正好前些日子赶上团队分享，于是趁此机会把知识框架梳理了一下。通过这张图可以清楚的看到自己的不足……技术了解的足够多，但是泛而不精，需要加深对于基础知识的理解。另外就是软实力严重不足，亟待提升。]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端组件化之路的一些思考与被神化的MVVM]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2FSome-Thoughts-On-The-Way-Of-Front-End-Componentization-And-MVVM-Deified%2F</url>
    <content type="text"><![CDATA[当初上手使用的时候就直接使用的 Vue，简单方便且直接。但最近在思考为什么三大框架得以挤掉 jQuery 变得流行，至于流行的原因众说纷纭，但我认为真正的原因只有两个：提供一种简单方便的开发范式，你不需要知道框架的运行原理就可以快速方便的开发出一个网站第二个原因则是最重要的：因为数据和 DOM 的同步并不简单。简单方便的开发范式先说第一个：无论是 Vue、React还是Angular实际上都默认提供了一种简单方便并且可维护的项目组织结构方式：组件。无论是 Vue的单文件组件还是 React 的tsx都鼓励将一个完整的网站、页面的不同组成部分拆分成一个组件，再像搭积木一样将它们拼接起来。这样所构建的网站可维护性良好、更容易构建出来超大规模项目 — — 超过数十万行代码的 js 项目。你再也不需要使用类似于jQuery一样类似于意大利面条一样的开发方式了。当然，事实上在 MVVM 框架出现之前有各种各样的方法将项目拆分，但的确很少有像 jsx 一样优雅的项目组织方式了。万幸我没有经历过那样一个时代。数据与 DOM 的同步问题JavaScript 的主要运行环境之一是浏览器，其责任是负责视图的渲染与用户的交互。随着前端页面的复杂程度的增长，js 必须承担起更大的责任。数据的改变与DOM的同步问题变成了一个非常头痛的问题。这里我想做一个简单的todo-list来说明这个问题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105class Todo &#123; constructor(msg) &#123; this.msg = msg; this.dom = null; this.createTodoItem(); &#125; createTodoItem() &#123; const todo = document.createElement('div'); todo.innerText = this.msg; this.dom = todo; &#125; remove() &#123; this.dom.remove(); this.dom = null; &#125; destroy() &#123; this.remove(); &#125; &#125; class Diff &#123; constructor(option, index, data) &#123; this.op = option; this.index = index; this.data = data; &#125; &#125; class TodoWrapper &#123; constructor(wrapper) &#123; if (typeof wrapper === 'string') &#123; wrapper = document.querySelector(wrapper); &#125; this.wrapper = wrapper; this.container = null; this.todos = []; this.todoDoms = []; this.createContainer(); &#125; render(diff) &#123; switch (diff.op) &#123; case 'add': this.addTodoItemDom(diff.index, diff.data); break; case 'remove': this.removeTodoItemDom(diff.index, diff.data); break; &#125; &#125; addTodoItemDom(index, todo) &#123; const sibling = this.todoDoms[index]; if (this.todoDoms.indexOf(todo) &gt;= 0) &#123; return; &#125; if (!sibling) &#123; this.container.appendChild(todo.dom); &#125; else &#123; this.container.insertBefore(todo.dom, sibling); &#125; &#125; removeTodoItemDom(index) &#123; const todo = this.todoDoms[index]; todo.remove(); this.todoDoms.splice(index, 1); &#125; addTodoItem(index, todo) &#123; if (this.todos.indexOf(todo) &gt;= 0) &#123; return; &#125; this.todos.splice(index, 0, todo); const diff = new Diff('add', index, todo); this.render(diff); &#125; removeTodoItem(index, todo) &#123; if (this.todos.indexOf(todo) &gt;= 0) &#123; return; &#125; this.todos.splice(index, 1, todo); const diff = new Diff('remove', index, todo); this.render(diff); &#125; createContainer() &#123; const container = document.createElement('div'); container.classList.add('todo-container'); this.wrapper.appendChild(container); this.container = container; &#125; destroy() &#123; this.wrapper = null; this.container = null; &#125; &#125;如此复杂的操作也是MVVM出现的原因。我们不需要再关注 DOM 的同步问题，只需要关注数据的改变即可。当数据改变的时候，我们的视图会随之变化。用Vue举例12345678910111213141516171819202122// in .vue&lt;template&gt; &lt;div class="todo-wrapper"&gt; &lt;template v-for="todo in todoList"&gt; &lt;Todo :msg="todo.msg" /&gt; &lt;/template&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default Vue.extend(&#123; name: 'todoList', components: &#123; Todo, &#125; data() &#123; return &#123; todoList: [], &#125; &#125;&#125;)&lt;/script&gt;是不是简单多了？三大框架的流行使得现在出现很多脱离了框架就不会进行网站开发的“偏科生”之前有一篇特别有名的文章 2015前端组件化框架之路 · Issue #19 · xufei/blog · GitHub 推荐在学习框架的同时读一读，大概可以理解在15年那个分叉路口的风起云涌，也大致能理解为什么现在三大框架三足鼎立。有些框架被历史放弃，有些则激流勇进。被神化的MVVM不久之前 Vue 在 github 的 star 数量超过了 react。但其实随着我接触前段时间的增长，我发现我更加喜欢 react 的开发方式，即使我最先接触的是 Vue。用于比较 Vue 与 React 区别的文章有很多，我在这里只想谈谈我自己的使用感受。就使用方式而言，Vue 是传一个配置文件给构造函数，而 React 则是配合 babel 的 jsx 转换自己写一个组件的类。ES6提供了标准的 Class，这让构建一个 React 组件时继承方式变得简单，当然，Vue 也提供了自己的 mixin 方式来实现，但总觉得有些别扭。当然，我并不是说Vue不好。什么是 MVVM 呢？就我自己而言的理解来说，数据驱动，使开发人员的关注点从视图分离，不需要注重数据与视图同步的过程。就实现方式而言，Vue通过es5所提供的 getter 和 setter 方法来实现依赖手机与视图更新，而React 则是通过手动触发。就效果而言，Vue的实现方式可以实现精准dom更新（因为Vue是深度绑定，如果是数组则会遍历整个数组使其响应化），而React则因为使用了数据更新的浅拷贝换取性能优势。这里仅以 Vue 为例相信对于 Vue 有一定了解的人都听说过 Watcher， Vue 实际上是使用观察者模式来实现 MVVM（不是发布订阅模式）在Vue初始化的时候实际上会进行一次渲染以触发数据的getter进行依赖收集。由于依赖收集与视图的更新依赖于getter/setter，为了达到这个目的，Vue需要深度遍历Data的每一个属性使其响应化（深度遍历每一个属性为其绑定上getter/setter，如果是数组，则会遍历整个数组）。当页面的变量达到非常大的时候，对于性能的需求与内存的需求都是一个不小的数字。我没有深入研究过React，不过相信过程都是差不多的，都需要进行依赖收集。MVVM的确是前端工程化的利器，但还是需要用客观的思想去看待问题，有时候自己瞎想，当工程规模更大的时候、更大的时候、更大的时候，MVVM 或许就会成为限制前端发展的瓶颈。]]></content>
  </entry>
  <entry>
    <title><![CDATA[谈谈 rem 与 vw -- rem]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2FTalk-About-Rem-And-Vw----Rem%2F</url>
    <content type="text"><![CDATA[谈谈rem与vw — rem写这篇文章的原因，源于我在头条的面试。面试官问到了关于手机端适配rem的问题，这个问题非常有意思，想和大家分享一下：123Q:能谈谈rem的作用吗，与em有什么区别？A: rem 是html 的font-size大小，一般为 16px， em 是父节点的 font-size 大小Q: 我们为什么要用rem去做手机的适配？如果rem只是根节点字体大小的话，那么rem 其实和px 、em没有区别，rem解决了什么问题？我之前确实做过几个简单的手机H5页面，只是在使用淘宝的lib-flexible方案，只觉得rem是解决方案的结果，但是从没想过为什么要使用rem来做手机端的适配。当我再次去看淘宝的lib-flexible的时候，发现此方案已经不被推荐了，取而代之的是《如何在Vue项目中使用vw实现移动端适配》,于是想借此机会将 rem 与 vw 一起总结一下。手机端适配模式## 一些基本概念具体内容可以查看《使用Flexible实现手淘H5页面的最终适配》,在这里，我只对其中的一些概念谈一谈自己的理解。viewport简单来说，viewport严格等于浏览器视窗大小（不包含滚动条），但是在移动设备上有些复杂，分为 visualviewport 与 layoutviewport。这里不做详细解释，可以查看《viewports剖析》来了解详细内容，看完这篇文章，你会明白为什么在html头部 emmet 会自动帮你生成1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;设备独立像素（虚拟像素）设备独立像素是软件概念上的一个像素，一个设备独立像素可以对应多个物理像素，对应关系由相关系统控制（我们不用管），CSS像素（即写在css中的1px）就是一种设备独立像素。例如苹果是Retina屏，1px（虚拟像素） = 4px（物理像素，dpr=2）盗一张手淘的图：### dprdpr实际上是一个比值，标识一个虚拟像素对应几个物理像素。正常屏幕1个 CSS 像素对应1个物理像素，dpr=1，Retina 屏幕1个 CSS 像素对应 n^2 个物理像素，dpr 为 n。例如上面那张图 dpr 就是2，因为一个 CSS 像素对应 4 个物理像素， 长对应2个，宽对应2个。remrem 简单来说是 html 的 font-size 大小，一般默认为 16px，与 em 的父节点 font-size 大小不同。一般 rem 方案解决小屏幕适配问题就是通过 JavaScript 动态改变 html 元素的 font-size 大小进行适配（组件使用 rem 作为度量）lib-flexiblelib-flexible是淘宝团队推出的一种 rem 适配方案，它帮我们解决了不同屏幕如何设置 html 的 font-size 大小与 dpr 的问题。可以看到 lib-flexible 里面有两个版本， master 里面用正则匹配 IOS 端和 Android 端，而Branch 2.0 版本则取消了对于 dpr 的适配，具体我会在下面进行介绍。rem 解决了什么问题首先要明确的一点是 data-dpr 和 rem 解决的是两个维度的问题。 Rem 解决的是移动端适配的问题， data-dpr 是在解决了移动端适配问题的基础上用于提升视觉效果。在 Web App 上面，我们需要禁止页面缩放。可以试着打开一下手机淘宝页面，你会发现你无法将这个页面放大。考虑一个问题，你需要为一个 375px 大小的屏幕做页面，页面充满整个屏幕, 里面有一个 200px 大小的弹窗，你需要如何去实现它？1234567.wrapper &#123; width: 375px; .dialog &#123; width: 200px; &#125;&#125;如果这么做就 GG 了，当这个页面放到大一些的屏幕上（例如 414px的屏幕），那么显示出来的效果会出现留白。 414 是 iPhone * Plus 的尺寸，如果放到 ipad 上面那么留白会更大。我们如何解决这个问题呢？如果能够有一种动态的修改元素的长度就好了。rem 就是这样一种原理，我们的组件使用 rem 进行编写，然后使用 JavaScript 动态设置 rem 到 px 的映射关系，这样就可以实现对于不同手机页面的适配了。上 lib-flexible 源码123456// 经过精简var docEl = document.documentElement;function setRemUnit () &#123; var rem = docEl.clientWidth / 10 docEl.style.fontSize = rem + 'px' &#125;具体 rem 的计算我会在下面介绍，核心代码实际上就是为 html 元素设置一个 font-size 而已。lib-flexible 设置 dpr 又是为了什么？为了解决“极致的1px”问题。再次把这张图放一下：在 Retina 屏幕上面，1个 CSS 像素实际上对应着4个物理像素（dpr=2的情况）。当我们在屏幕上画1px 的线时，Retina 屏幕实际上是2个物理像素宽。我们要实现“极致的1px”就是希望在Retina屏幕上画出一条1个物理像素宽的细线。原理其实也很简单，对于 dpr=2的设备，设置 rem 的值为正常值的 2 倍，将需要画出“极致的线”的地方使用1px表示，再将页面缩小2倍，这样1px的线就变成了“0.5px”，实际上为1个物理像素来表示。同理，对于 dpr=n 的设备，将 rem 值设为正常的 n 倍，在对页面缩放 n 倍。现在的 lib-flexible 有两个版本，master 版本和 2.0 版本。在 master 版本中使用 正则来判断系统种类（IOS/Andorid），但是只对 IOS 系统做了 dpr 的适配，对于 Android 手机，统一设置 dpr =1；实际上使用 rem 配合 dpr 缩放的方式有非常多的问题。最明显的例子就是安卓机 dpr 的混乱，例如 VIVO 的某款手机甚至出现了 dpr 为小数的情况（上文我们介绍到，1个 CSS 像素对应多少个物理像素 dpr 就是几，显然不可能出现小数位的情况），所以使用缩放来实现“极致的1px”兼容性并不是很好。有团队的做法是将 dpr 设置有问题的机型进行上报，然后收集成一个白名单，再根据白名单在 lib-flexible 对于有问题的机型进行单独适配，然而这个工作量一般的小团队没有精力去做……所以我们可以看到 2.0 版本已经舍弃了这种做法。1234567891011121314// 进行了精简// detect 0.5px supportsvar docEl = document.documentElement;if (dpr &gt;= 2) &#123; var fakeBody = document.createElement('body') var testElement = document.createElement('div') testElement.style.border = '.5px solid transparent' fakeBody.appendChild(testElement) docEl.appendChild(fakeBody) if (testElement.offsetHeight === 1) &#123; docEl.classList.add('hairlines') &#125; docEl.removeChild(fakeBody)&#125;可以看到这个版本对于设备进行了一个测试，如果该设备支持 0.5px 的书写方式，那么就在 html 元素上面添加一个 hairlines 的类,我们在使用的时候只需要在header中添加.hirlines div {border-width: 0.5px}就可以了。例如：123456789101112131415161718192021// some device support 0.5 px&lt;!DOCTYPE html&gt;&lt;html lang="en" class="hairlines"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div &#123; boder: 1px solid #000; &#125; .hairlines div &#123; border: 0.5px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是极致的1px&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;这样，如果支持 0.5 px，就会出现一条非常细的线，否则就按照正常的显示方式。Rem的映射方式这个问题其实很简单，首先我们设定一个基于设计稿的 rem 基准值，然后在真实设备上乘一个设计稿对真实设备的比值：而 lib-flexible 则默认规定了 rem 的取值为屏幕宽度的十分之一Rem的一些问题使用 rem 方式布局其实有很多问题。我们使用 rem 转换出来的 px 往往有很多小数点，所以最终的展示效果的 CSS 长宽实际上是经过四舍五入的。因此往往我们需要手动去调整“最后的1px”，这给我们带来了很多的麻烦。因此 rem 确实是对移动端适配的一种解决方案，但并非无懈可击。]]></content>
  </entry>
  <entry>
    <title><![CDATA[软件过程与项目管理(四)]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2FSoftware-Process-And-Project-Management-(iv)%2F</url>
    <content type="text"><![CDATA[4-CMMI能力成熟度模型集成过程能力通过遵循某个过程，有能力预见未来所得到的结果范围过程性能：特定项目遵循某过程所得到的实际结果的度量过程能力轮廓：可以用二维平面中的一系列点来表示过程能力轮廓过程维：描述执行什么过程（干啥）能力维：描述某个过程执行多好### 衡量成熟度的尺度评估模型## CMM主要思想专门针对软件产品的质量管理和质量保证标准系统工程是连续式的，其他模型是分级式的CMMI 能力成熟度模型集成是如何做好软件的最佳实践的集合级别差异## CMMI的表示形式连续式和阶段式CMMI主要内容CMMI概念体系要通过高级别的评估，要满足这个级别以下的所有级别的标准过程域(PA)过程域是指在单个过程域中的一组实践，当这个域中的实践全部履行时，就能满足一组有重要意义的目标。过程域并非是对过程的描述实践：经执行可以达到一个过程域的目标的行为特殊目标（SG）作用于一个过程域，描述为了满足该过程域而必须实现的独有特征。特殊实践（SP）为达到相关的特殊目标而采取的重要行为通用目标(GG)同样的目标出现在多个过程域中，每个过程域都有且只有一个通用目标通用实践（GP）保证与过程域相关的过程都能有效、可重复、可持续的行为共同特性一种将通用实践分类的方法]]></content>
  </entry>
  <entry>
    <title><![CDATA[软件过程与项目管理（三）]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2FSoftware-Process-And-Project-Management-(3)%2F</url>
    <content type="text"><![CDATA[软件过程与项目管理软件过程改进过程改进帮助软件企业对其软件过程的改进进行计划、措施制 定以及实施。软件过程改进环境一个软件过程改进环境不断要对过程的定义及文档化加以支持，而且要实现对软件监控、反馈、角色改进及活动的支持，从而最终建立一个可持续改进的软件过程.软件过程改进步骤评估:发现弱项或存在的问题计划:针对弱项或问题制定改进计划改进:实施改进监控计划监控:检验实施的情况，纠正不符合要求的现象软件过程改进框架是支撑软件过程运作的框架以及结构基础不但包含人员组织、管理方面所涉及的角色与职责，而且还包括执行过程活动、获取并分析过程活动结果、过程反馈以及过程改进活动所需的技术工具和运行架构。必须拥有两类架构组织与管理方面的架构技术方面的架构主要目的: 主要目的是支持软件工程组活动，从而能够以一种高效、系统并且连续改进的方式进行软件开发。影响方面：过程效率产品质量软件工程师生产率时间、费用评估的准确性项目计划的跟踪组织与管理方面的架构包括用于建立过程监控和对过程执行实施 强制措施的角色与职责全局的角色：是针对整个组织的确保过程有效性为项目组成员以及团队活动提供支持和指导提供项目组活动状体啊报告以实施对项目的监管局部的角色： 针对项目组一级或者针对特定的关键过程域的体工队日常工作的支持提供个体软件工程活动报告，监控实施效果指导帮助阮江工程师提高其个体软件过程水平角色负责人角色：支持整个软件过程改进活动的负责人。拥有对预算及资源授权的权力，并可监控企业的获利情况。应是企业的高层管理者。管理角色：一个可以通过委员会对软件过程改进活动提供管理方面指导与战略方向的人。协调角色：共同的SEPG(软件工程过程组)，在协调及技术指导方面为软件过程改进团队提供帮助。负责制定过程改进计划。改进团队角色：软件过程改进团队(软件PIT)，具体实施软件过程改进活动的人员。[图片上传失败…(image-57de25-1513791811221)]实施负责人/领导：应是企业高管具有建立软件过程改进方案的权利在企业中确保过程改进能持续获得足够的管理权限协调软件过程改进活动与企业其他活动之间的关系。确保软件过程中强制度量的实施推动软件过程改进的动力执行委员会： 是由一群高级经理以及一线经理组成的一个政策制定团体，制定整个企业过程改进以及监控策略为SPI活动设定战略目标检查软件过程评估结果批准软件过程改进组的结构设置批准不同软禁过程改进组的实施计划和优先级设置监控软件过程改进组获得相应的权利和资源检查当前政策的执行以及资源和过程管理的情况。与高层或有相同计划的组织进行协商在不同的软件过程改进组之间进行协调软件工程过程组（SEPG）：是企业级的工作组，他的任务是协调、实现对整个企业中所有软件过程改进组及其活动的支持。协调企业中所有的过程改进活动，对不同级别上的管理活动加以维护。提名并召集软件过程改进组（PIT）成员，协调他们的工作。SEPG目标与任务- 软件过程改进组（PIT）：由软件工程师组成的团队，他们利用部分工作时间，针对某一特定的领域进行过程改进。实现关键过程域的过程改进活动。对当前过程的分析、再设计以及文档话。对过程在设计问题的思考为新过程编写相应的文档。为实现对新过程的支持，评估、选择不同的方法、技术与攻击。为过程开发相应的培训课程在SEPG的帮助下协调与其他相关软件PIT的关系。为过程实施情况的监控制定相应的规程、制定反馈机制并提供针对反馈数据的分析工具。实体职责### 技术方面的架构软件过程技术方面的架构包括用于支持软件工程过程组与过程改进团队的技术架构、计算机设备以及工具一个高效灵活的技术过程架构是进行有效的过程改进和过程维护的基础。包含内容#### 过程支持工具保存及管理过程定义和过程数据的工具检索及传播过程定义和过程数据的工具支持软件过程和管理过程活动的工具软件过程改进规划图提供一个表明有效软件过程特征的模型，规划出实现高效软件过程的行动步骤实现软件过程需要经历的阶段及层次以及为实现过程目标所必经的关键点可以是公开发表的过程标准要求渐进的改进，通常讲过程成熟度划分为不同的级别应标示不同层次的过程的特点应标示不同级别软件开发环境的特征、特点与属性，并告诉人们要做什么应说明每个级别面对的调整，并在制定计划时将挑战考虑进去规划图模型阶段性过程改进规划图模型由一系列成熟度界别所构成，每个过程域都处于一个特定的级别连续性过程改进规划图模型每个过程有自己的成熟尺度比较#### CMMI## 软件过程评估方法评估组织当前软件过程、活动以及架构的方法和技术十一过程改进规划图为依据进行度量、检测过程的成熟度级别，并总结出当前活动的特点，给出优势与弱势，判断出当前过程对质量、成本、进度方面进行控制以避免问题的能力。评估内容不应将注意力只集中于过程的文档化应关注是否进行了软件管理以及具体实施的培训应通过下面几个判断过程是否有效是否有管理以及组织方面的授权过程的实施结果是否被度量与监控反馈机制是否已建立是否有明确的过程负责人，过程是否真正得到了改进不应只通过几个问题就对过程加以评估，应该通过检查及小组讨论深入到软件开发和项目管理中去应由受过专业培训的专业软件人员进行评估应遵循一个已定义的过程改进规划图进行评估评估目标了解并检查组织当前软件工程实施状况与整个组织的运行情况确定过程中的优势及弱势，确定软件过程改进的关键领域促进过程改进活动的开展并让组织ing到这参与到改进过程中来为过程改进活动提供框架帮助获得应有的权利并对评估活动提供支持评估方式### 软件过程评估领域组织即-&gt;项目级-&gt;个体级别即[图片上传失败…(image-7998cf-1513791811221)]评估流程## 软件过程改进计划根据评估所发现的问题，有针对性的制定出相应的改进方案，并将方案转化为软件过程改进的行动计划通过执行过程改进计划，将会提高现有的软件过程水平，同时提高过程的规范化程度以及过程的有效性。前提已通过评估了解软件过程的状态，而且已采用一种改进规划图来度量软件过程改进的状态，并以此得出过程改进的目标成功判断标准可行性灵活性资源的可获得性评估的风险]]></content>
  </entry>
  <entry>
    <title><![CDATA[软件过程与软件管理（一）]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2FSoftware-Process-And-Software-Management-(1)%2F</url>
    <content type="text"><![CDATA[软件过程与项目管理（一）软件危机在软件开发及维护的过程中所遇到的一系列严重问题，这些问题皆可能导致软件产品的寿命缩短、甚至夭折。主要表现项目运行超出预算项目运行延期软件质量低软件通常不符合要求项目无法管理，且代码难以维护软件工程软件工程试图以工程的原理、原则和方法进行原件开发，以解决软件危机。定义应用计算机科学、数学及管理科学等原理，开发软件的工程，是一门交叉学科目标提高开发质量和生产率开发过程的改善是达到目标的重要因素过程改善+技术=完善的解决方案软件过程软件过程是开发和维护软件及其相关产品所涉及的一系列活动。即软件生存周期所涉及的一些列相关活动。主要解决问题做什么（what）怎么做（how）过程要素任务、工作产品、角色、工具角色使用一定的工具来执行任务，将输入的工作产品转换为输出的就工作产品（用UML建立Use Case）任务是有序的组织和协调谁来执行什么任务，在何时、何地、如何来做、为什么要做。软件过程的三个方面过程定义：将过程所包含的活动及程序文档化过程监控：过程的监控与强制过程培训：让每一个人都了解过程的内容过程分类支持过程质量保证记录审核管理评审配置管理纠正/预防措施实现过程策划需求分析设计开发测试发布组织/管理过程人力资源信息技术财务市场业务发展设备维护以过程为中心的优点### 过程管理目的：让过程能够被共享、服用，并得到持续的改进。注重循序渐进的积累。积累项目中的各个环节的实践经验和项目管理的实践经验，保证生产力持续的发展。规范过程的特点：有明确定义有相应的培训具有强制性与可服从性可不断改进过程规范是人们在过程活动中需要遵守的约定和规则，包括已定义的操作方法、流程和文档模板。软件过程在整个软件开发的过程中约束着相关人员按照预定开发流程进行工作。优点：可以使团队形成统一协调的工作方式可以提高团队工作能力在关键时刻决定生死的因素过程规范定制：让过程的执行者参与到过程的设计中过程的执行者可以提供反馈意见三个层次：过程层阶段层活动层软件过程改进软件过程改进帮助软件企业对其软件（制作）过程的改变进行计划、措施制定以及实施。软件过程改进环境：一个软件过程改进环境不断要对过程的定义及文档话加以支持，而且要实现对软件监控、反馈、角色改进及活动的支持，从而最终建立一个可持续改进的额软件过程。PDCA循环过程改进带来的益处：产品质量提高缩短上市时间更高的生产率实际证明软件过程改进确实能够给企业带来巨大回报软件过程模型软件过程模型是软件过程的抽象表示一个软件过程模型是软件生命周期全部活动和任务的结构框架能够直观表达软件生命周期的全过程，明确规定要完成的主要活动、任务和开发策略瀑布模型瀑布模型式是最典型的预见性的方法，严格遵循预先计划的需求分析、设计、编码、集成、测试、维护的步骤顺序进行。步骤成果作为衡量进度的方法，例如需求规格，设计文档，测试计划和代码审阅等等。主要问题：它的严格分级导致的自由度降低，项目早期即作出承诺导致对后期需求的变化难以调整，代价高昂。瀑布式方法在需求不明并且在项目进行过程中可能变化的情况下基本是不可行的。螺旋模型螺旋模型将瀑布模型和快速原型模型结合起来，强调了其他模型所忽视的风险分析，特别适合于大型复杂的系统。“螺旋模型”刚开始规模很小，当项目被定义得更好、更稳定时，逐渐展开。“螺旋模型”的核心就在于不需要在刚开始的时候就把所有事情都定义清楚。定义最重要的功能，实现它，然后听取客户的意见，之后再进入到下一个阶段。如此不断轮回重复，直到得到您满意的最终产品。制定计划：确定软件目标，选定实施方案，弄清项目开发的限制条件；风险分析：分析评估所选方案，考虑如何识别和消除风险；实施工程：实施软件开发和验证；客户评估：评价开发工作，提出修正建议，制定下一步计划。螺旋模型很大程度上是一种风险驱动的方法体系，因为在每个阶段之前及经常发生的循环之前，都必须首先进行风险评估。迭代和增量模型迭代式开发也被称作迭代增量式开发或迭代进化式开发，是一种与传统的瀑布式开发相反的软件开发过程，它弥补了传统开发方式中的一些弱点，具有更高的成功率和生产率。什么是迭代式开发?每次只设计和实现这个产品的一部分, 逐步逐步完成的方法叫迭代开发, 每次设计和实现一个阶段叫做一个迭代.在迭代式开发方法中，整个开发工作被组织为一系列的短小的、固定长度（如3周）的小项目，被称为一系列的迭代。每一次迭代都包括了需求分析、设计、实现与测试。采用这种方法，开发工作可以在需求被完整地确定之前启动，并在一次迭代中完成系统的一部分功能或业务逻辑的开发工作。再通过客户的反馈来细化需求，并开始新一轮的迭代。敏捷模型是一种应对快速变化的需求的一种软件开发能力,更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发中人的作用。特点人和交互 重于过程和工具。可以工作的软件 重于求全而完备的文档。客户协作重于合同谈判。随时应对变化重于循规蹈矩。四种模型对比项目的敏捷开发,敏捷开发小组主要的工作方式可以归纳为：作为一个整体工作； 按短迭代周期工作； 每次迭代交付一些成果:关注业务优先级； 检查与调整。瀑布模型：也就是从需求到设计，从设计到编码，从编码到测试，从测试到提交大概这样的流程，要求每一个开发阶段都要做到最好。特别是前期阶段，设计的越完美，提交后的成本损失就越少。迭代式开发：不要求每一个阶段的任务做的都是最完美的，而是明明知道还有很多不足的地方，却偏偏不去完善它，而是把主要功能先搭建起来为目的，以最短的时间，最少的损失先完成一个“不完美的成果物”直至提交。然后再通过客户或用户的反馈信息，在这个“不完美的成果物”上逐步进行完善。螺旋开发：很大程度上是一种风险驱动的方法体系，因为在每个阶段之前及经常发生的循环之前，都必须首先进行风险评估。敏捷开发：相比迭代式开发两者都强调在较短的开发周期提交软件，但是，敏捷开发的周期可能更短，并且更加强调队伍中的高度协作。强调适应性。]]></content>
  </entry>
  <entry>
    <title><![CDATA[软件过程与项目管理（二）]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2FSoftware-Process-And-Project-Management-(2)%2F</url>
    <content type="text"><![CDATA[过程思维面向过程的思维与面向任务的思维区别是什么面向过程的思维：注重的是总体目标、各部分工作的协调性和一致性，从而消除了各部分工作之间的冲突，提高了总体的工作效率，从而有效的达到工作的总体目标面向任务的思维：注重人物、作业、人员、组织架构，特点是指派人员去完成，解决局部问题。软件过程与软件质量解决软件问题的重要一步是把整个软件工作当作软件过程来对待，使其能够控制、度量和改进。软件过程成熟度一个特定软件过程得到清晰的定义、管理、测量、控制的有效制度。软件过程成熟度的对比角色与职责2. 处理变更的方式3. 对问题发生的反应4. 可信性5. 对工作人员的奖励6. 预见性### 高效软件过程（与规范过程相同）特点：有明确定义有相应培训具有强制性和可服从性可不断改进实现：过程文档化应有相应培训过程必须背监控并被强制执行高效过程保证机制：明确过程所有者过程培训过程实施情况的度量和反馈过程使用者的反馈吸收外部反馈（法律、法规、标准的变更，技术、方法的进步，政策调整，目标客户的特征、需求的变更）实施和检验实现条件:### 过程认同与过程制度化过程的要求已经变成全体员工的自觉行动，得到大家的认同和坚持遵循时，过程便成为制度化的。要靠过程文化和过程基础设施的支持过程文化指人们的习惯和行为收到过程思维和过程管理原则的影响。人们对于规范化过程时完全认同的，就是说，人们的活动自觉的安过程要求去做。过程文化应具有自己的特性。#### 过程基础设施支持软件过程的基础框架和结构基础过程基础设施包含组织和管理基础设施、技术基础设施组织和管理基础设施：组织和管理的岗位和职责技术基础设施：支持定义过程、开展过程活动、获取和分析过程有关绩效反馈以及不断进行过程改进活动所必须的技术工具和平台。组织管理基础设施：建立、监控和推进过程活动的岗位及其职责质量管理与认证体系近代质量管理的理论与实践 是软件过程成熟度学说的基础CMMI]]></content>
  </entry>
  <entry>
    <title><![CDATA[操作系统（一）]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2FOperating-System-(I)%2F</url>
    <content type="text"><![CDATA[操作系统概述计算机系统硬件计算机的实体部分，是有形的设备和装置的总称软件控制计算机运行的程序及其相关信息操作系统层次结构下层的软件为上一层提供服务，上层的软件依靠下层的软件完成任务。什么是操作系统一个系统软件 - 为用户提供方便操作计算机的手段使系统能够高效运转管理和控制系统中的各种资源协调系统中的各个组成部分计算机程序，作用和地位比较特殊 - 为用户使用计算机提供基础支持负责提高整个计算机系统的效率操作系统的任务方便用户使用计算机：提供接口提高系统效率：管理资源管理资源资源类型：储存器各种输入输出设备以文件形式存在的各种数据各种可执行程序因此资源管理包括：储存器管理I/O设备管理文件管理进程管理系统调用形式上与普通函数相似，但有本质区别使程序能够运行核心态指令指令级别核心级 - 比较重要、会对系统产生致命影响的指令用户级处理机的工作状态核心态 - 通过设置硬件标记实现处理机才能执行核心级指令用户态 - 不能执行核心级指令，只能执行用户级指令操作系统类型管理的硬件规模 - 嵌入式操作系统微机操作系统中小型机操作系统大/巨型机操作系统响应和处理用户任务的方式 - 批处理操作系统分时操作系统实时操作系统管理资源的内容 - 单机操作系统网络操作系统分布式操作系统]]></content>
  </entry>
  <entry>
    <title><![CDATA[记一次小米前端面试题]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2FRemember-A-Millet-Front-End-Test%2F</url>
    <content type="text"><![CDATA[2019.05.09 更新，修复了文章中的一些认知错误，更新了一些格式，填补了一些坑这两天参加了一次小米的面试，面试方式比较随意，直接用微信聊的。感觉面试题有些意思，所以想记下来，也使我学到了不少东西。Q:定义这样一个函数1234&gt; function doRepeat(func, times, wait) &#123;&gt; &gt; &#125;&gt;参数分别是需要 repeat的函数， repeat的次数，每次repeat的间隔使用方式如下：调用这个函数能返回一个新函数，比如传入的是 alert，这个函数的调用就是12&gt; var repeatedFun = doRepeat(alert, 10, 5000);&gt;调用返回的这个新函数，如: repeatFun(“hellworld”);会依次 alert 十次 helloworld，每次间隔5秒这个题目很简单，单从要求来看考验的是闭包函数，所以我们只需要使用延时函数再return一个函数就能达到要求，答案网上也能查到。我使用setInterval函数实现的，这里只给出部分关键性代码。1234567891011121314151617181920212223242526function doRepeat(func, times, wait) &#123; // 检查参数是否存在 if (!func || !times || !wait) &#123; return function () &#123; &#125;; &#125; // 检查参数类型 if (!checkType(func, ['function']) &amp;&amp; !checkType(times, ['Number', 'String']) &amp;&amp; !checkType(wait, ['Number', 'String'])) &#123; return function () &#123; &#125;; &#125; // 进行不规则类型的类型转换 times = exchange(times, 'Number'); wait = exchange(wait, 'Number'); let i = 0; return function repeat() &#123; const _args = arguments; const handler = setInterval(function () &#123; if (i == times) &#123; clearInterval(handler); return; &#125; func(_args[0]); i++; &#125;, wait) &#125;&#125;这个函数非常简单，请在十分钟内完成就好。但是这里想说一下几个要点：一个是程序的可用性：即程序是否可以正常运行，这个是最基本的条件，如果不能达到请自觉面壁30秒。另外一个是程序的健壮性：是否检查传参的完整性？是否检查参数类型？我想强调这一点，因为javascript是自动类型的语言，在运行过程中进行类型的检测是十分重要的问题。另外一个是程序的可读性：这个也是最基本的问题之一，代码风格良好的程序应该可读性强，并且仅添加必要的注释。程序的和谐性：即在程序出错的情况下是否依然可以返回标准的数据格式？可以看到我在检查参数出错以后返回1return function() &#123;&#125;这么做可以避免因为此函数出错而影响其他的功能性函数。程序的包容性：可以看到我在函数中进行了类型转换。这也是我在工作中遇到的问题，当我们参与工作的协作之时，我们往往需要调用同事或者其他人的函数，而javascript的自动类型也可能导致传过来的参数类型并不标准，如果我们能在代码中给予这些“小问题”适当的支持，那么我们的函数将会友好很多。这里我将并不标准的字符串类型转换为了Number类型。这些特点实际上是我在某篇文章上面看到的，但是实际应用以后发现受益良多，我会在找到这篇文章以后把链接发上来。我坚信良好的代码风格可以帮助我们避免很多坑，并且严格遵守这一点。但是实际上我写的这个函数并不完善，这一点也将在后面的面试题中考到。Q:请再用setTimeout实现一下果然考到了这一点，setTimeout在实际运用的过程中会有很多的坑，最明显的问题就是异步问题，这也是我一开始使用setInterval来实现的原因。下面给出代码：12345678910111213141516171819202122232425function doRepeat(func, times, wait) &#123; // 检查参数是否存在 if (!func || !times || !wait) &#123; return function () &#123; &#125;; &#125; // 检查参数类型 if (!checkType(func, ['function']) &amp;&amp; !checkType(times, ['Number', 'String']) &amp;&amp; !checkType(wait, ['Number', 'String'])) &#123; return function () &#123; &#125;; &#125; // 进行不规则类型的类型转换 times = exchange(times, 'Number'); wait = exchange(wait, 'Number'); return function repeat() &#123; const _args = arguments; // 如果次数大于0先执行一遍，避免setTimeout延迟问题 if (times &gt; 0) &#123; func(_args[0]); &#125; for (let i = 1; i &lt; times; i++) &#123; (window.setTimeout)(func(_args[0]), wait); &#125; &#125;&#125;这是我一开始写的代码，但是实际上这段代码是错误的。我在setTimeout一行中使用了立即执行函数，但是立即执行函数并不会阻塞函数的运行，所以这段代码还是会在N秒过后一下子把所有的函数全部执行一遍。请注意，这里又一个小坑，使用setTimeout是延迟执行函数，如果直接使用第一次传入的函数不会立即执行，所以需要先做一次判断。Q:能不能不要一下子就设定好所有的setTimeout在完成一个setTimeout后再去递归一下这次考的是递归，没有什么难度。12345678910111213141516171819202122232425262728293031function doRepeat(func, times, wait) &#123; // 检查参数是否存在 if (!func || !times || !wait) &#123; return function () &#123; &#125;; &#125; // 检查参数类型 if (!checkType(func, ['function']) &amp;&amp; !checkType(times, ['Number', 'String']) &amp;&amp; !checkType(wait, ['Number', 'String'])) &#123; return function () &#123; &#125;; &#125; // 进行不规则类型的类型转换 times = exchange(times, 'Number'); wait = exchange(wait, 'Number'); let i = 0; // 返回函数主体 function repeat() &#123; // 如果次数达到则退出 if (times === i) &#123; return; &#125; const _args = arguments; func(_args[0]); i++; // 尾递归 return setTimeout(repeat.bind(this, _args[0]), wait); &#125; return repeat;&#125;写到这里，突然觉得这个函数其实还是不够健壮。我们来分析一下参数，func参数，默认是一个函数。times参数，默认是一个非负数。wait也默认是一个非负数。如果传入的参数times是一个负数，那么这个函数将会陷入死循环。这里做检测是否存在过度优化的问题？我还是抱有疑虑。Q: 这里如果有多个参数怎么办？比如传入的函数叫console.log,可以接受多个参数A:方法比较多，比如可以规定传参的格式，用数组将参数包裹起来，或者使用argumentsQ: show me the code这里实际上有个坑，就是IE9的setTimeout只能传入两个参数（IE的梗已经被玩烂了）,这里可以使用bind函数来解决这个问题。123456789101112131415161718192021222324252627282930function doRepeat(func, times, wait) &#123; // 检查参数是否存在 if (!func || !times || !wait) &#123; return function () &#123; &#125;; &#125; // 检查参数类型 if (!checkType(func, ['function']) &amp;&amp; !checkType(times, ['Number', 'String']) &amp;&amp; !checkType(wait, ['Number', 'String'])) &#123; return function () &#123; &#125;; &#125; // 进行不规则类型的类型转换 times = exchange(times, 'Number'); wait = exchange(wait, 'Number'); let i = 0; // 返回函数主体 function repeat() &#123; // 如果次数达到则退出 if (times === i) &#123; return; &#125; const _args = [].slice.call(arguments); // 如果次数大于0并且是第一次执行则先执行一遍，避免setTimeout延迟问题 func(..._args) // 尾递归 return setTimeout(repeat.bind(this, _args), wait); &#125; return repeat;&#125;这里同样解释一下这行代码的作用1const _args = [].slice.call(arguments);可以看到我在下面的代码中使用了展开运算符...，但是展开运算符的使用需要迭代器。arguments不是数组，所以没有迭代器。如果展开运算符后面不是对象的话，会自动构建成一个对象。在这里如果直接使用 ...arguments 的话效果类似于对数组使用展开运算符，所以这句话删掉也没问题的。考虑以下代码：1234567(function()&#123; console.log([] instanceof Array);&#125;)() // true(function()&#123; console.log(arguments instanceof Array);&#125;)() // false这些大概就是全部的面试过程，不过最后俺没去成小米，因为时间实在是不合适……最后想给自己挖个坑，也出个升级版的问题Q: 请将这道题用setTimeout配合Generator函数实现一遍这几天考试，等考完试我再来填……抱歉现在才回来填坑，然而现在已经有了异步神器 async/await1234567891011121314151617181920212223242526function defer(func: Function, delay: number, ...args: any[]): Promise&lt;any&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; try &#123; window.setTimeout(() =&gt; &#123; func(...args); resolve(); &#125;, delay); &#125; catch(e) &#123; reject(e); &#125; &#125;);&#125;function doRepeat(func: Function, times: number, wait: number) &#123; async function* provider(...args: any[]) &#123; let i = 0; while(i &lt; times) &#123; yield defer(func, wait, ...args); i++; &#125; &#125; return async function consumer(...args: any[]) &#123; for await (let res of provider(...args) &#123;&#125; &#125;&#125;generator 是一个很强大的特性，来源于 python，它可以和 promise 来配合用来实现异步（比如大名鼎鼎的 co），但现在 async/await 已经出来了，异步还是用它吧：123456789101112131415161718192021function defer(func: Function, delay: number, ...args: any[]): Promise&lt;any&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; try &#123; window.setTimeout(() =&gt; &#123; func(...args); resolve(); &#125;, delay); &#125; catch(e) &#123; reject(e); &#125; &#125;);&#125;async function doRepeat(func: Function, times: number, wait: number) &#123; return async function(...args: any[]) &#123; let i = 0; while(i &lt; times) &#123; await defer(func, wait, ...args); &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[观察者模式 vs 订阅发布模式]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2FObserver-Mode-Vs.-Subscription-Publishing-Mode%2F</url>
    <content type="text"><![CDATA[一直很好奇订阅/发布模式和观察者模式有什么区别，一直以来都把这两者混为一谈。实际上，我理解中的观察者模式是1:n，而订阅发布模式是m:n的模式。观察者模式需要观察者直接在被观察这种注册，两者直接耦合，一般是同步的，而订阅发布模式则存在一个调度中心，观察者与被观察者不关心对方是谁，只通过消息通信，一般是异步的。观察者模式123456789101112131415161718class DownloadTask &#123; private status: 'loadding' | 'finished' | 'pause' = 'loadding'; constructor(public id: number, public taskName: string) &#123;&#125; public finish() &#123; this.status = 'finished'; console.log(`Task $&#123;this.taskName&#125; is notifed`); &#125; public pause() &#123; this.status = 'pause'; &#125; public start() &#123; this.status = 'loadding'; &#125;&#125;123456789101112131415161718192021222324252627class DownloadList &#123; public downloadList: DownloadTask[]; constructor() &#123; this.downloadList = []; &#125; public add(task: DownloadTask) &#123; this.downloadList.push(task); &#125; public remove(id: number) &#123; for (let task of this.downloadList) &#123; if (task.id === id) &#123; const index = this.downloadList.indexOf(task); this.downloadList.splice(index, 1); &#125; &#125; &#125; public get(index: number) &#123; return this.downloadList[index]; &#125; public length() &#123; return this.downloadList.length; &#125;&#125;12345678910111213141516171819class DataHub &#123; public downloadList = new DownloadList(); public addDownloadTask(task: DownloadTask) &#123; this.downloadList.add(task); &#125; public removeDownloadTask(task: DownloadTask) &#123; this.downloadList.remove(task.id); &#125; public notify() &#123; const len = this.downloadList.length(); for (let i = 0; i &lt; len; i++) &#123; this.downloadList.get(i).finish(); &#125; &#125;&#125;123456789const task1 = new DownloadTask(1, 'task1');const task2 = new DownloadTask(2, 'task2');const dataHub = new DataHub();dataHub.addDownloadTask(task1);dataHub.addDownloadTask(task2);dataHub.notify();订阅发布模式123456789101112131415161718class DownloadTask &#123; private status: 'loadding' | 'finished' | 'pause' = 'loadding'; constructor(public id: number, public taskName: string) &#123;&#125; public finish() &#123; this.status = 'finished'; console.log(`Task $&#123;this.taskName&#125; is notifed`); &#125; public pause() &#123; this.status = 'pause'; &#125; public start() &#123; this.status = 'loadding'; &#125;&#125;123456789101112131415161718192021222324252627class DownloadList &#123; public downloadList: DownloadTask[]; constructor() &#123; this.downloadList = []; &#125; public add(task: DownloadTask) &#123; this.downloadList.push(task); &#125; public remove(id: number) &#123; for (let task of this.downloadList) &#123; if (task.id === id) &#123; const index = this.downloadList.indexOf(task); this.downloadList.splice(index, 1); &#125; &#125; &#125; public get(index: number) &#123; return this.downloadList[index]; &#125; public length() &#123; return this.downloadList.length; &#125;&#125;12345678910111213141516171819class DataHub &#123; public downloadList = new DownloadList(); public addDownloadTask(task: DownloadTask) &#123; this.downloadList.add(task); &#125; public removeDownloadTask(task: DownloadTask) &#123; this.downloadList.remove(task.id); &#125; public notify() &#123; const len = this.downloadList.length(); for (let i = 0; i &lt; len; i++) &#123; this.downloadList.get(i).finish(); &#125; &#125;&#125;123456789101112131415161718192021222324252627282930class DepManager &#123; public events: &#123; [index: string]: ((...rest: any[]) =&gt; void)[]; &#125; = &#123;&#125;; public registerChannel(evtName: string) &#123; if (!this.events[evtName]) &#123; this.events[evtName] = []; &#125; else &#123; console.error('already registed'); &#125; &#125; public subscribe(evtName: string, cb: any) &#123; if (this.events[evtName]) &#123; this.events[evtName].push(cb); &#125; &#125; public emit(evtName: string, payload?: any) &#123; if (this.events[evtName]) &#123; try &#123; const subscribers = this.events[evtName]; for (let i = 0; i &lt; subscribers.length; i++) &#123; subscribers[i].call(null, payload); &#125; &#125; catch (e) &#123;&#125; &#125; &#125;&#125;123456789101112131415161718const task1 = new DownloadTask(1, 'task1');const task2 = new DownloadTask(2, 'task2');const taskList = new DownloadList();taskList.add(task1);taskList.add(task2);const manager = new DepManager();const dataHub = new DataHub();manager.registerChannel('datahub');manager.subscribe('datahub', () =&gt; &#123; console.log('dispatch');&#125;);manager.emit('datahub');总结其实比较明显的地方在于观察者模式提供了一种点对多点的交互，但是当业务逻辑复杂的时候这种关系难以维护，因为需要单独对于被观察者进行注册，而订阅发布者模式则提供了一种统一事件管理方式，但相对的，实现所需要的成本则更高一些。注：以上的代码源自知乎：https://www.zhihu.com/question/23486749]]></content>
  </entry>
  <entry>
    <title><![CDATA[操作系统（二）]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2FOperating-System-(2)%2F</url>
    <content type="text"><![CDATA[进程调度进程进程是程序在计算机中的一个执行过程。程序是静态的，而进程是动态的。每个进程都有一个进程控制块，操作系统用来存放进程有关的信息。进程的创建四种主要事件会导致进程的创建：系统初始化正在运行的程序执行了创建进程的系统调用用户请求创建一个新的进程一个批处理作业的初始化进程的终止进程的终止通常由以下四种主要事件导致：正常退出（自愿）出错推出（自愿）严重错误（非自愿）被其他进程杀死（非自愿）进程的状态基本状态：执行、就绪、阻塞其他状态：挂起、僵死、等待挂起：将暂不执行的进程换出到外村，节省内存空间### 进程调度的时机新进程的创建当前进程的退出正在执行的进程阻塞I/O中断发生调度算法分类CPU的分配方式 - 非剥夺式（非抢占式）剥夺式（抢占式）系统的分时方式 - 批处理系统交互系统实时系统调度目标公平（让每个用户满意）平衡（系统效率最高）批处理系统调度目标吞吐量：系统每小时完成的作业数周转时间： 一个作业从提交到完成时的统计平均时间CPU利用率批处理系统中的调度算法先来先服务按照请求CPU的顺序使用CPU - 就绪队列时间先后的顺序队首取，队尾加易于理解、便于实现对短作业不公平最短作业优先提高平均周转时间预知作业运行时间最短剩余时间优先 - 最短作业优先的强占版新作业比正在执行的作业剩余时间短长作业无限期等待 - 有失公平性最高响应比优先算法响应比 - 作业等待时间/作业所需运行时间优先考虑短作业防止长作业无限等待交互系统调度目标响应时间 - 快速响应交互请求交互系统中的调度算法轮转法使用时间片进行调度的算法，时间片段用完后会排到队尾，考虑到CPU效率与用户等待时间一般设置为20ms-50ms - 未用完时间片就I/O阻塞的，当I/O就绪后到就绪队尾重新排队。可以为其单设队列，优先考虑I/O后就绪进程直至其用完时间片。优先级 - 优先级高的进程先运行，同优先级的进程轮转（同一队列中轮转）每个进程设立优先级，高优先级的队列中没有进程，调度下一级队列 - 静态设定动态设定：在优先级高的进程运行一个时间片后降低其优先级（防止高优先级进程独占CPU饿死低优先级的进程）彩票法向进程提供各种系统资源的彩票调度时随机抽取彩票，拥有该彩票的资源得到资源 - 可给重要的今晨更多的彩票协作进程可以交换彩票公平分享法为每个用户分配一定比例的CPU时间 - 假设用户1开了四个进程ABCD，用户2开设一个进程E，则CPU调度有可能为AEBECEDEAEBE…按照比例个用户之间挑选进程实时系统调度目标满足截止时间 - 正确的但是迟到的应答比没有更糟糕硬实时 - 必须满足的绝对的截止时间软实时 - 可以容忍偶尔的错失截止时间基本条件提供必要的信息系统处理能力强采用抢占式调度机制具有快速切换机制调度算法最早截止时间优先算法先把截止时间早的任务给完成，否则这个任务如果在截止时间后才完成就没有意义了。进程切换开销时间和空间上的系统开销保存和恢复进程的上下文Linux的进程调度这里朱凯豪师兄总结的特别好，这里附上链接]]></content>
  </entry>
  <entry>
    <title><![CDATA[面向对象建模分析（四）]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2FObject-oriented-Modeling-Analysis-(iv)%2F</url>
    <content type="text"><![CDATA[什么是动态建模所有系统均可表示为：静态结构和动态结构状态图、活动图、顺序图和协作图描述系统结构和行为，适合描述系统在不同的时间点是如何动态交互的。活动图活动图与状态图的区别活动图能够表示并发活动活动图是面向对象的，流程图示面向过程的- 带泳道的活动图## 状态图只有当行为的改变和状态有关时才能创建状态图状态图通常只用于描述单个对象的行为，如果要描述对象间的交互，最好采用时序图或协作图。两个核心元素：圆角矩形表示的状态；称为转换的箭头线。## 顺序图消息的语法格式[前置消息列表][警戒条件][消息顺序号][返回值:=]([参数列表])## 协作图类元素、关联元素、消息流消息标签]]></content>
  </entry>
  <entry>
    <title><![CDATA[面向对象建模分析（一）]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2FObject-oriented-Modeling-Analysis-(I)%2F</url>
    <content type="text"><![CDATA[面向对象分析方法软件的错误是怎样产生的？软件工程的挑战有哪些交付的软件不是用户需要的用户需求的变化风险没有管理无力的团队管理软件软件是一种特别的产品，随着规模和复杂性的进步以及应用领域的扩大逐渐形成了工程。是计算机中与硬件相互依存的另一部分，包括程序、数据和说明文档。程序是按照设计要求和性能指标设计的指令序列数据是程序能够正常操纵信息的数据结构说明文档是用于开发和维护软件程序的各种图文资料。软件工程软件工程是软件的工程性方法，涵盖了所有生命周期，并提供了一整套工程性方法来指导软件开发。软件工程是一门研究如何用系统化、规范化、数量化等工程原则和方法去进行软件的开发和维护的学科。包含：1. 软件开发技术 2. 软件项目管理软件工程三要素：方法、工具、过程软件工程应包括的知识（10个）：软件需求、软件设计、软件构建、软件维护、软件配置管理、软件工程管理、软件工程过程、软件工程工具和方法、软件质量软件的发展历程经历了哪几个阶段，每个阶段的特点是什么？第一阶段：程序设计阶段 - 个人英雄主义的开发、软件开发就是程序设计、不考虑通用型文档不全只有程序的概念，没有软件的概念。采用汇编语言、机器语言应对计算机性能问题第二阶段：软件设计阶段 - 程序规模增大、需小组协作生产由小组运行、维护程序重要性提升，不再被视作硬件的附属成分。在计算机系统的开发过程中与硬件工程师共同起主导作用。第三阶段：传统软件工程阶段 - 采用工程化生产方式软件产业兴起软件开发成功率、质量大大提升。软件工程并发环境及并发环境涌现，度量问题得到重视。第四阶段：现代软件工程阶段 - OOP广泛使用软件开发技术逐渐成熟软件危机指计算机软件的开发和维护过程中所遇到了一系列严重问题。软件生命周期包括分析、设计、实现、测试和维护等。软件工程的框架软件工程目标：正确性、可用性、费用合算软件工程活动：需求、设计、实现、确认、支持软件工程原则：适宜开发范型、合适设计方法、高质量工程支持软件过程是为了获得高质量软件所需要完成的一系列步骤。生命周期模型把生命周期划分成那些阶段以及执行顺序，也称为软件过程模型。常见模型：瀑布模型、快速原型模型、增量模型、螺旋模型瀑布模型应用场景：大型软件项目；需求明确；需求变化少特点：阶段间具有顺序性和依赖性推迟实现的观点。质量保证的观点优点：严格规定了必须提交的文档按活动划分的检查点当前阶段完成后，只需关注后续阶段缺点：阶段划分固定、阶段间大量文档增加工作量开发模型线性，只有在过程结束才能看到成果，增加风险早期的错误可能要等到末期测试才能发现，带来严重后果快速原型模型应用领域：客户不熟悉软件、沟通理解困难优点：减少需求不明确带来的开发风险更好和客户沟通减少技术、应用风险，缩小成本，提高产品质量缺点尽可能快速建造原型、限制开发人员创新所选技术工具不一定主流，效率低可能导致产品设计差客户确定真正需求、原型可能被抛弃增量模型（演化模型）适用范围：需求比较明确、架构稳定优点：及时反馈、适应变化好客户看到不断变化的软件，降低开发风险团队士气的鼓舞缺点：需要开放式的体系结构，维护难度大容易退化为边做边改模型、使软件过程控制失去整体性螺旋模型适用范围：大型复杂的系统优点：强调可选方案以及约束条件支持软件重用有助于提升软件质量缺点：要求客户接受相信风险分析风险分析成本过大则无意义需善于识别风险且准确结构化方法（面向功能、数据流软件开发方法，结构化生命周期法）五个阶段：规划、分析、设计、实施、运行维护Jackson方法的表示：顺序、选择、重复面向对象软件开发方法自底向上的归纳、自顶向下的分解，尽可能运用人类自然思维方式要点：客观世界由各种对象组成所有对象划分为类类具有登记对象之间通过消息交互三大重要特征：封装、继承、多态基本概念：对象、类、封装…核心概念：对象、类]]></content>
  </entry>
  <entry>
    <title><![CDATA[面向对象建模分析（二）]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2FObject-oriented-Modeling-Analysis-(ii)%2F</url>
    <content type="text"><![CDATA[需求工程需求工程的基本概念什么是需求工程？对系统应该提供的服务和所受到的约束进行理解、分析、建立文档、检验的过程软件需求的困难应用领域的广泛性非功能性需求建模技术的缺乏沟通上的困难软件需求的内容功能需求对系统应该提供的服务、功能以及系统在特定条件下的行为的描述非功能需求如性能指标、道德约束等领域需求是由软件系统的应用领域所决定的特有的功能需求需求分析的作用定义软件范围及必须满足的约束确定软件功能、性能与其他系统成分接口建立数据模型、功能模型、行为模型最终提供需求规格说明，并作为评估质量的依据需求工程基本活动获取需求需求分析与建模确认需求进化需求需求获取三个问题：明确需要获取的信息（what）明确所获取信息的来源和渠道（where）怎样获取需求（how）需求获取技术面谈法众包：一个公司和机构吧过去由员工执行的工作任务，以自由自愿的方式外包给非特定的大众网络的做法。问卷调查法需求专题讨论会观察用户的工作流程原型化方法基于用例的方法需求分析与建模三个层次：需求分析需求建模需求规格说明需求分析常用技术分解抽象多视点需求分析方法功能分解方法- 将系统看作若干功能模块的集合，每个功能可以分解为子功能（递归） - 不足之处 需要人工完成&lt;br&gt; 无法对描述的准确度进行验证&lt;br&gt; 难以适应需求变化 &lt;!-- --&gt; 结构化分析方法不考信息建模法是从数据的角度对现实世界建立系统的信息模型。ER图面向对象分析方法识别问题域内的对象，分析他们之间的关系，并建立起三类模型。]]></content>
  </entry>
  <entry>
    <title><![CDATA[从实现一个红绿灯到函数式编程]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2FFrom-Implementing-A-Traffic-Light-To-Functional-Programming%2F</url>
    <content type="text"><![CDATA[我认为函数式编程的本质是把函数当作变量来使用。最近接触了React，我们可以发现在React中处处存在函数式编程的思想，我们将JSX写成一个函数的返回值，并且在render中调用她们。函数是对于过程的抽象，我们将过程抽象成一个函数，然后根据不同的场景传入不同的变量值从而得到不同的结果。而函数式编程是对于函数的抽象，我们把函数看作是一个变量，然后根据不同的场景传入不同的函数值从而得到不同的结果。我希望可以通过实现一个小的demo来讲清楚这件事，这个demo是我很久以前在某个技术网站看到的，具体的网址已经记不清楚了，鉴于小伙伴们对于我所讲的函数式编程的概念非常感兴趣，所以我将这个例子翻了出来，自己将它重新实现一遍。若是没有讲清楚或错误的地方，则是受限于我的浅薄的技术功底，并希望被指正。红绿灯函数客户希望我们实现一个红绿灯函数，每隔1秒钟，变换一次信号，无限循环。可以使用console.log来模拟信号灯亮的过程，即在控制台打印’绿灯亮’,1s后继续打印’黄灯亮’,1s后打印’红灯亮’…无限循环实现这个效果非常简单，直接上代码123456789101112131415161718192021function semaphores() &#123; setTimeout(()=&gt;&#123; console.log('绿灯亮'); setTimeout(() =&gt; &#123; console.log('黄灯亮'); setTimeout(() =&gt; &#123; console.log('红灯亮'); semaphores(); &#125;, 1000) &#125;, 1000) &#125;,1000) &#125;// delay 1s// 绿灯亮 // delay 1s// 黄灯亮// delay 1s// 红灯亮// delay 1s// ...但是很明显，这样的函数及其不优雅，我们的红绿灯只有三种颜色，如果要是有十几种颜色的霓虹灯闪来闪去的话，我们就要嵌套十几层代码了。这样可读性实在是太差了，于是我们希望可以把它优化一下。仔细分析一下我们的代码就会发现，上面的demo有非常多的冗余代码，setTimeout在一个函数中被重复使用了三次，每次只不过是一个嵌套再打印不同的红黄绿灯而已，我们为什么不把公共部分提取出来呢？把红黄绿灯提取成变量，代码质量会好很多。so出现了下列的代码：12345678910111213141516171819202122232425const TRAFFIC_LIGHT = [ '绿灯', '黄灯', '红灯']function semaphores(lightList = [], count = 0) &#123; // 控制器 let lightLength = lightList.length; return setTimeout(() =&gt; &#123; console.log(`$&#123;lightList[count % lightLength]&#125;`); count ++; semaphores(lightList,count); &#125;, 1000)&#125;// delay 1s// 绿灯亮 // delay 1s// 黄灯亮// delay 1s// 红灯亮// delay 1s// ...我们还可以进一步优化，同时将时间抽离:12345678910111213141516171819202122232425262728const TRAFFIC_LIGHT = [ ['绿灯', 1000], ['黄灯', 2000], ['红灯', 3000]]function semaphores(lightList = [], count = 0) &#123; const lightLength = lightList.length; return function handleSemaphores()&#123; const [light, time] = lightList[count % lightLength]; return setTimeout(() =&gt; &#123; console.log(`$&#123;light&#125;亮`); count ++; handleSemaphores(); &#125;, time) &#125;&#125;// delay 1s// 绿灯亮 // delay 2s// 黄灯亮// delay 3s// 红灯亮// delay 1s// ...我们可以更加容易修改我们的代码，以应对将来可能的需求变更。这也是我们常见的函数形式。变量只是 Number、String、Object、undefined、null、Boolean，但是我们再次将问题变得复杂一些：我们的红绿灯效果良好，客户非常满意，并且希望扩展应用范围。为了应对可能到来的困惑，我们需要在每次信号灯亮起的时候添加上一条提示语，提醒剩余时间。不同的应用场景将有不同的提示语。这也非常简单，我们只需要多加一条语句就可以完成:123456789101112131415161718192021222324252627282930313233const TRAFFIC_LIGHT = [ ['绿灯', 1000], ['黄灯', 2000], ['红灯', 3000]]function semaphores(lightList = [], count = 0) &#123; const lightLength = lightList.length; return function handleSemaphores()&#123; const [light, time] = lightList[count % lightLength]; return setTimeout(() =&gt; &#123; console.log(`$&#123;light&#125;亮`); // add here!!! console.log('这是一条提示语'); count ++; handleSemaphores(); &#125;, time) &#125;&#125;// delay 1s// 绿灯亮 // 这是一条提示语// delay 2s// 黄灯亮// 这是一条提示语// delay 3s// 红灯亮// 这是一条提示语// delay 1s// ...但随着我们的应用场景进一步增多，我们的红绿灯将广泛的用于医疗、运输、零售行业，对于这些行业我们需要在信号灯亮起时拥有不同的操作，有的是发出声响、有的是打印提示语、有的是发出警报、有的是打开开关…那么我们是不是需要把上面的那份代码到处拷贝一下，然后修改位于16行的代码，分别把它修改为发声、打印、报警、开关控制…显然一般的函数已经无法满足我们的需求了，这时候我们就需要函数式编程。函数式编程我上面只是为了引出函数式编程的例子，所以举例夸张了一些。事实上函数式编程并不是非常高大上的概念，它就和面向对象、面向过程一样，只是一种编程的范式，在实际中拥有着非常广泛的应用（例如JSX）就像我一开始提到的那样，函数式编程的核心不过是将函数当作变量那样来使用。我们希望改造一下我们的红绿灯函数，使我们的函数在信号灯亮后，可以在不同的场景使用不同的参数，我们来设计一下这个函数.首先我们需要传入一个函数，所以我们在形参列表中加入一个handler的变量，便于我们使用它。然后在我们希望使用它的地方使用就好了。12345678910111213141516171819202122const TRAFFIC_LIGHT = [ ['绿灯', 1000], ['黄灯', 2000], ['红灯', 3000]]// 请注意我们在这里加入了一个参数handlerfunction semaphores(lightList = [], handler, count = 0) &#123; const lightLength = lightList.length; return function handleSemaphores()&#123; const [light, time] = lightList[count % lightLength]; return setTimeout(() =&gt; &#123; console.log(`$&#123;light&#125;亮`); // 在这里使用它 handler &amp;&amp; handler(light, time); count ++; handleSemaphores(); &#125;, time) &#125;&#125;我们可以这样使用上面的函数:123456789101112131415161718192021// 我们只需要在不同的场景改变不同的handler就可以了const handler = function (light, time) &#123; console.log('函数式编程好爽啊'); console.log(`$&#123;light&#125;亮$&#123;time&#125;毫秒~~`)&#125;const doTrafficLight = semaphores(TRAFFIC_LIGHT, handler);const trafficTimeHandler = doTrafficLight();// delay 1s// 绿灯亮// 函数式编程好爽啊// 绿灯亮1000毫秒~~// delay 2s// 黄灯亮// 函数式编程好爽啊// 黄灯亮2000毫秒~~// delay 3s// 红灯亮// 函数式编程好爽啊// 红灯亮3000毫秒~~// ...我们更可以优化一下上面的函数，使得不同等亮起时使用不同的行为函数:123456789101112131415161718192021222324252627282930313233343536373839const TRAFFIC_LIGHT = [ ['绿灯', 1000, function() &#123; // do something... &#125;], ['黄灯', 2000, function() &#123; // do something... &#125;], ['红灯', 3000, function() &#123; // do something... &#125;]]// 我们去掉了handler!!!!function semaphores(lightList = [], count = 0) &#123; const lightLength = lightList.length; return function handleSemaphores()&#123; const [light, time, handler] = lightList[count % lightLength]; return setTimeout(() =&gt; &#123; console.log(`$&#123;light&#125;亮`); // 在这里使用它 handler &amp;&amp; handler(light, time); count ++; handleSemaphores(); &#125;, time) &#125;&#125;// delay 1s// 绿灯亮// dosomething1...// delay 2s// 黄灯亮// dosomething2...// delay 3s// 红灯亮// dosomething3...// ...函数式编程的抽象程度更高，它是对于过程的抽象。如果没有传入的参数作为支撑，那么这个函数毫无意义，比较明显的例子是JavaScript中的map和reduce。这是最主要的概念，剩下的概念则都是一些规定，帮助我们写出更好的更健壮的函数式函数，相信理解了我刚刚所说的例子，再去理解其他概念会容易许多。]]></content>
  </entry>
  <entry>
    <title><![CDATA[事件稀释 Debounce & Throttle]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2FEvent-Dilutes-Debounce-And-Throttle%2F</url>
    <content type="text"><![CDATA[事件稀释是一个在实际开发过程中经常遇到的问题，例如一次鼠标滚动可能触发几十次滚动事件，当我们在懒加载的时候如果不做稀释的话，很可能用户滚动一下鼠标就会发出几十次ajax请求，这简直是一场灾难。稀释原理比较常见的解决方法是 Debounce和Throttle。两者的目的都是为了稀释事件，但是原理有所不同。Debounce函数的理念是“推迟执行”，即把N次连续事件只执行一次。Throttle函数的理念是“时间稀释”，即N次连续事件在规定时间内最多执行一次。举个例子来说，如果把事件触发比作是乘客，而事件的执行是公交车的话，当我们连续滚动屏幕不停触发’scrolling’事件的时候，就相当于来一个乘客，上一辆公交车，就发车，一辆公交车只搭载一名乘客就出发了。而 Debounce 函数则是“推迟发车”，即我们规定公交车等1分钟，每来一名乘客，公交车就多等一分钟，这样只要乘客到达的时间间隔小于1分钟，公交车就会无限等待下去，直到某一次两名乘客到达的时间间隔大于1分钟，公交车发车了。如果不来乘客，公交车就不发车。Throttle函数则是对于时间的稀释，对于Throttle的公交车，即使有乘客，那么每一分钟最多只发车一次，即使上一名乘客是59秒达到而下一名乘客是1分01秒到达，公交车依旧会在1分钟时准时发车，下一名乘客只能等待下一班车了。同样，如果不来乘客，公交车就不会发车。下面我希望能通过一些函数Demo来说明Debounce与ThrottleDebounce这里给出了一个Debounce函数的示例，我是用class的方式实现的123456789101112131415161718192021222324252627282930313233class Debounce &#123; handleFunction: Function; time: number | string; handler: number; context: object; constructor(handleFunction: Function, time: number | string, context?:Object) &#123; this.handleFunction = handleFunction || (() =&gt; &#123; &#125;); this.time = +time || 0; // 解决this指针作用域 this.context = context || &#123;&#125;; this.carry = this.carry.bind(this); this.clear = this.clear.bind(this); // setTimeout 句柄 this.handler = 0; &#125; carry(): void &#123; if (this.handler) &#123; this.clear(); &#125; this.handler = setTimeout(() =&gt; &#123; this.clear(); this.handleFunction.apply(this.context); &#125;, this.time); &#125; clear(): void &#123; clearTimeout(this.handler); this.handler = 0; &#125;&#125;核心是Debounce.prototype.carry函数，我们可以看到，在每次调用的时候首先检测当前有没有正在执行的Debounce函数，如果有的话，则取消上一次的执行，再添加一次新的延迟执行函数，从而达到上述效果。如果你想测试一下上面的函数，可以用以下方式调用：1234567import Debounce from 'path/to/debounce';const a = new Debounce(function a() &#123; console.log("hi");&#125;, 1000);window.addEventListener('scroll', a.carry);再新建个HTML，然后把body的height设置大点就OK了。Throttle同样给出Throttle函数1234567891011121314151617181920212223242526272829303132333435class Throttle &#123; handleFunction: Function; time: number | string; handler: number; context: object; constructor(handleFunction: Function, time: number | string, context?:Object) &#123; this.handleFunction = handleFunction || (() =&gt; &#123; &#125;); this.time = +time || 0; // 解决this指针作用域 this.context = context || &#123;&#125;; this.carry = this.carry.bind(this); this.clear = this.clear.bind(this); // setTimeout 句柄 this.handler = 0; &#125; carry(): any &#123; if (this.handler) &#123; return; &#125; this.handler = setInterval(() =&gt; &#123; this.handleFunction.apply(this.context); this.clear(); &#125;, this.time); &#125; clear(): void &#123; clearInterval(this.handler); this.handler = 0; &#125;&#125;export default Throttle;可以看到其中的carry函数在规定时间内最多执行一次。最近在项目中遇到的一些坑其实这篇文章在写出以后确实在项目中遇到了一些问题，所以再看这篇文章写的还是有些不太全面。对于事件稀释，Throttle和Debounce都不过是稀释方法的一种。大致思想都是在对于在某一段时间内频繁触发的事件合并为一次进行请求。但是实际业务中的事件稀释方式要多得多。对于长页面的lazy load，不一定需要按时间为单位，亦可以按请求为单位，因为我们需要避免的事一秒发出几十次请求。对于不同的场景，我们要分析具体需要稀释的事情是什么。在错误的场景使用不合适的稀释方式可能反而会造成性能问题。事件稀释的精髓在于对于“事件”的稀释，不要拘泥于形式。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Draft.js的事件处理机制]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2FDraft.js-Event-Handling-Mechanism%2F</url>
    <content type="text"><![CDATA[Draft 事件处理机制Draft.js 内部封装了一系列基础的事件处理函数，当事件触发时，这些函数接收当前event，并基于此生成new editorState，我们在接收到new editorState后再将该数据绑定到Draft上，这就是Draft的单向数据流。其中react层只负责视图层，我们将通过一些流程图与源码的展示来详细介绍这一点。事件在 Draft 内部的传递Draft 由事件驱动，任何事件的触发最终都会被转化为一个新的EditorState。上图是一个简单的流程图，展现了事件在 Draft 内部的传递机制。react只负责事件的绑定与view的展示，将Draft中内置的事件editorBlur等方法与原生事件blur进行绑定，下面给出了Draft源码进行说明：123456789101112131415161718// DraftEditor.react.js// 经过精简render() &#123; &lt;div // 将原生事件与Draft内置事件相绑定 onBeforeInput=&#123;this._onBeforeInput&#125; onBlur=&#123;this._onBlur&#125; onCopy=&#123;this._onCopy&#125; onCut=&#123;this._onCut&#125; onDragEnd=&#123;this._onDragEnd&#125; onDragEnter=&#123;this.onDragEnter&#125; ... // 请暂时忽略下面这部分 &lt;DraftEditorContents &#123;...editorContentsProps&#125; /&gt; &lt;/div&gt; &#125;通过上面的代码部分我们可以看到，react将原生事件与内置事件做了绑定，例如将_onBlur绑定到了原生事件onBlur上面。而_onBlur内部的事件则被单独抽象出来，与视图层完全解耦。Draft运用了一些很酷的小技巧来解决内置事件与原生事件的绑定问题：1234567891011121314151617181920212223242526272829303132333435// 经过精简import React, &#123; Component &#125; from 'react';import &#123;onBlur, onCopy, onFocus&#125; from './logicLayer';const handler = &#123; onBlur(e) &#123; editOnBlur(e); &#125; onCopy(e) &#123; editOnCopy(e); &#125; onFocus(e) &#123; editonFocus(e); &#125;&#125;class DraftEditor extends Component &#123; constructor(props)&#123; super(props); // 事件绑定 this._onBlur = this._buildHandler('onBlur'); this._onCopy = this._buildHandler('onCopy'); this._onCut = this._buildHandler('onCut'); this._onInput = this._buildHandler('onInput'); ... &#125; _buildHandler(eventName) &#123; return e =&gt; &#123; const method = this._handler &amp;&amp; this.handler[eventName]; method &amp;&amp; method(this, e); &#125; &#125;&#125;核心函数是_buildHandler,通过此函数进行事件绑定的分发。通过这种方式，可以完成视图层与逻辑层的解耦。任何事件的触发最后都会被转化为一个new EditorState,通过onChange（update）方法抛出，我们接收到new EditorState后，再将其绑定到Draft上面，由Draft负责EditorState的转换，最终通过react渲染出来。也就是说，任何new EditorState都一定会被Draft抛给我们，再由我们绑定到Draft上面进行展示，EditorState不是一个内部状态。当然Draft对EditorState进行转换的过程远远没有这么简单，实际情况要复杂的多，这点我们将会在下面提到。通过上面所提到的这种方式，Draft完成了由事件到状态对象的转化，并且完成了数据的单向流动。Draft 事件层和展示层的分离我在上面大致画出了draft的react层是如何划分的。其实这个图并不准确，但是用来说明已经够用了。在react层将事件绑定层与实践展示层分离：1234567891011121314151617181920// DraftEditor.react.js// 经过精简/** * Event层 */render() &#123; &lt;div // 将原生事件与Draft内置事件相绑定 onBeforeInput=&#123;this._onBeforeInput&#125; onBlur=&#123;this._onBlur&#125; ... /** * View 层 */ &lt;DraftEditorContents &#123;...editorContentsProps&#125; /&gt; &lt;/div&gt; &#125;仔细查看上面的代码，依旧是相同的render函数，这次我将事件绑定的部分隐去了大部分，主要可以看到在这个组件中引入了DraftEditorContents组件，这个组件就是事件的展示层。在此层中，储存了preEditorStatus,View层负责将diff过后的latestEditorStatus渲染出来。中间会经过一些过程，在此期间Draft会向外暴露一些端口用于处理类似于block样式与inline样式，具体内容会在扩展中提及。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Draft.js的数据结构]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2FDraft.js-Data-Structure%2F</url>
    <content type="text"><![CDATA[Draft.js的数据结构Draft.js使用EditorState来保存数据结构顶层，其中记录了用于展示数据的所有数据结构。本文将通过提供一系列的简单示例来简单介绍Draft.js的数据结构。不可变的数据结构Draft.js基于immutable.js实现了一种不可变的数据结构，基于这种数据结构，Draft.js实现了单项数据流，即 event -&gt; onChange -&gt; EditorStateEditorState 概览我在 CodePen 上面实现了一个简单的Demo用于展示EditorState，你可以在上面尝试一下。上图展示了一个完整的EditorState，我们可以轻易的猜测出一些属性的含义，比如currentContent记录了当前编辑器中展示内容的状态，selection中标识当前的选区，redoStack和undoStack分别是撤销、重做栈，而EditorState则提供了操作这些属性的顶层方法。样式展现Draft将样式分为块级样式与内联样式，块级样式之间线性排列，不可嵌套，内联样式则用数组记录，可以重叠。当我在draft中随意输入一些文字的时候，text将会记录下文字内容，而此时用于记录块级样式的type值为unstyled现在我们将H1（块级元素）应用于文本，我们可以发现用于标识块级样式的type值变为了header-one，当我们继续在该行输入的时候，将会同样被赋予H1样式。通过上述的数据结构我们可以发现，由于块级样式由type所规定，所以块级样式之间不可被嵌套，即不会出现无序列表嵌套有序列表的情况出现。对于同一块级元素中的文本内容，draft将其按照字符进行拆分,每一个字符的内联样式用数组进行展示，由此可以解决内联样式的嵌套问题。123456789[ ['ITALIC'], // 斜 ['ITALIC'], // 体 [], ['ITALIC','BOLD','UNDERLINE'], //斜 ['ITALIC','BOLD','UNDERLINE'], //体 ['ITALIC','BOLD','UNDERLINE'], //加 ...]Entity元数据Entity并不是一个难以理解的数据类型，Entity数据主要用于展示一些不可被分割的数据类型，例如图片、mention、超链接等。典型场景就是mention类型，详细来说，我们在日常使用中会在富文本编辑器中提及一些人， @xxx 的数据类型要求是一个统一整体，一旦 @xxx 中有某一个字符被删除，就有可能会出现 @ 出的名字和 @ 的对象不一致的情况。在上图中，我将插入的图片数据结构打印了出来，我们可以发现这是一个Entity，记录了data，mutability与type，Draft.js向外暴露了一个顶层接口，当Entity数据被注入的时候，可以通过这个接口来设计数据对象的展现方式，如下图123456789101112131415// Draft Editor&lt;Editor blockRendererFn=&#123;this.mediaBlockRenderer&#125;/&gt;​// mediaBlockRenderermediaBlockRenderer(block) &#123; if(block.getType() === 'atomic') &#123; return &#123; component: Media, editable: false, &#125; &#125; return null;&#125;1234567891011121314151617181920// Mediaconst Media = (props) =&gt; &#123; const entity = props.contentState.getEntity( props.block.getEntityAt(0) ); const &#123;src&#125; = entity.getData(); const type = entity.getType(); console.log(&#123;entity&#125;); let media; if (type === 'audio') &#123; media = &lt;Audio src=&#123;src&#125; /&gt;; &#125; else if (type === 'image') &#123; media = &lt;Image src=&#123;src&#125; /&gt;; &#125; else if (type === 'video') &#123; media = &lt;Video src=&#123;src&#125; /&gt;; &#125; return media;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[友情链接]]></title>
    <url>%2Fblog%2F2019%2F05%2F06%2Flinks%2F</url>
    <content type="text"><![CDATA[Frank’s Weblog]]></content>
  </entry>
</search>
