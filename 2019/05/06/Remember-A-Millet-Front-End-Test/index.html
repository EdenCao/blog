<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Cao Yong,ednencaox@gmail.com"><title>记一次小米前端面试题 · Eden's Blog</title><meta name="description" content="这两天参加了一次小米的面试，面试方式比较随意，直接用微信聊的。感觉面试题有些意思，所以想记下来，也使我学到了不少东西。

Q:
定义这样一个函数
function doRepeat(func, times, wait) {
}
参数分别是需要 repeat的函数， repeat的次数，每次repea"><meta name="keywords" content="JavaScript,TypeScript,Linux,macOS"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/blog/css/style.css"><link rel="stylesheet" href="/blog/css/blog_basic.css"><link rel="stylesheet" href="/blog/css/font-awesome.min.css"><link rel="stylesheet" href="/blog/css/atom-one-light.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/blog/images/logo@2x.png" style="width:127px;"><h3 title><a href="/">Eden's Blog</a></h3><div class="description"><p>一些奇奇怪怪的东西</p></div></div></div><ul class="social-links"><li><a href="http://github.com/EdenCao"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="archives/">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>记一次小米前端面试题</a></h3></div><div class="post-content"><p>这两天参加了一次小米的面试，面试方式比较随意，直接用微信聊的。感觉面试题有些意思，所以想记下来，也使我学到了不少东西。</p>
<blockquote>
<p>Q:</p>
<p>定义这样一个函数</p>
<p>function doRepeat(func, times, wait) {</p>
<p>}</p>
<p>参数分别是需要 repeat的函数， repeat的次数，每次repeat的间隔</p>
<p>使用方式如下：</p>
<p>调用这个函数能返回一个新函数，比如传入的是alert，这个函数的调用就是<br></p>
<p> var repeatedFun = doRepeat(alert, 10, 5000);</p>
<p>调用返回的这个新函数，如: repeatFun(“hellworld”);</p>
<p>会依次alert十次 helloworld，每次间隔5秒</p>
</blockquote>
<p>这个题目很简单，单从要求来看考验的是闭包函数，所以我们只需要使用延时函数再return一个函数就能达到要求，答案网上也能查到。我使用<code>setInterval</code>函数实现的，这里只给出部分关键性代码。</p>
<pre><code>function doRepeat(func, times, wait) {
    // 检查参数是否存在
    if (!func || !times || !wait) {
        return function () { };
    }
    // 检查参数类型
    if (!checkType(func, [&#39;function&#39;]) &amp;&amp; !checkType(times, [&#39;Number&#39;, &#39;String&#39;]) &amp;&amp; !checkType(wait, [&#39;Number&#39;, &#39;String&#39;])) {
        return function () { };
    }
    // 进行不规则类型的类型转换
    times = exchange(times, &#39;Number&#39;);
    wait = exchange(wait, &#39;Number&#39;);
    let i = 0;
    return function repeat() {
        const _args = arguments;

        const handler = setInterval(function () {
            if (i == times) {
                clearInterval(handler);
                return;
            }
            func(_args[0]);
            i++;
        }, wait)
    }
}
</code></pre><p>这个函数非常简单，请在十分钟内完成就好。但是这里想说一下几个要点：</p>
<ul>
<li><p>一个是程序的可用性：即程序是否可以正常运行，这个是最基本的条件，如果不能达到请自觉面壁30秒。</p>
</li>
<li><p>另外一个是程序的健壮性：是否检查传参的完整性？是否检查参数类型？我想强调这一点，因为javascript是自动类型的语言，在运行过程中进行类型的检测是十分重要的问题。</p>
</li>
<li><p>另外一个是程序的可读性：这个也是最基本的问题之一，代码风格良好的程序应该可读性强，并且仅添加必要的注释。</p>
</li>
<li><p>程序的和谐性：即在程序出错的情况下是否依然可以返回标准的数据格式？可以看到我在检查参数出错以后返回</p>
</li>
</ul>
<!-- -->
<pre><code>return function() {}
</code></pre><p>这么做可以避免因为此函数出错而影响其他的功能性函数。</p>
<ul>
<li>程序的包容性：可以看到我在函数中进行了类型转换。这也是我在工作中遇到的问题，当我们参与工作的协作之时，我们往往需要调用同事或者其他人的函数，而javascript的自动类型也可能导致传过来的参数类型并不标准，如果我们能在代码中给予这些“小问题”适当的支持，那么我们的函数将会友好很多。这里我将并不标准的字符串类型转换为了Number类型。</li>
</ul>
<!-- -->
<p>这些特点实际上是我在某篇文章上面看到的，但是实际应用以后发现受益良多，我会在找到这篇文章以后把链接发上来。我坚信良好的代码风格可以帮助我们避免很多坑，并且严格遵守这一点。</p>
<p>但是实际上我写的这个函数并不完善，这一点也将在后面的面试题中考到。</p>
<blockquote>
<p>Q:<br></p>
<p> 请再用setTimeout实现一下</p>
</blockquote>
<p>果然考到了这一点，setTimeout在实际运用的过程中会有很多的坑，最明显的问题就是异步问题，这也是我一开始使用<code>setInterval</code>来实现的原因。下面给出代码：</p>
<pre><code>function doRepeat(func, times, wait) {
    // 检查参数是否存在
    if (!func || !times || !wait) {
        return function () { };
    }
    // 检查参数类型
    if (!checkType(func, [&#39;function&#39;]) &amp;&amp; !checkType(times, [&#39;Number&#39;, &#39;String&#39;]) &amp;&amp; !checkType(wait, [&#39;Number&#39;, &#39;String&#39;])) {
        return function () { };
    }
    // 进行不规则类型的类型转换
    times = exchange(times, &#39;Number&#39;);
    wait = exchange(wait, &#39;Number&#39;);

    return function repeat() {
        const _args = arguments;
        // 如果次数大于0先执行一遍，避免setTimeout延迟问题
        if (times &gt; 0) {
            func(_args[0]);
        }
        for (let i = 1; i &lt; times; i++) {
            (window.setTimeout)(func(_args[0]), wait);
        }
    }

}
</code></pre><p>这是我一开始写的代码，但是实际上这段代码是错误的。我在setTimeout一行中使用了立即执行函数，但是立即执行函数并不会阻塞函数的运行，所以这段代码还是会在N秒过后一下子把所有的函数全部执行一遍。</p>
<p>请注意，这里又一个小坑，使用setTimeout是延迟执行函数，如果直接使用第一次传入的函数不会立即执行，所以需要先做一次判断。</p>
<blockquote>
<p>Q:<br></p>
<p> 能不能不要一下子就设定好所有的setTimeout<br></p>
<p> 在完成一个setTimeout后再去递归一下</p>
</blockquote>
<p>这次考的是递归，没有什么难度。</p>
<pre><code>function doRepeat(func, times, wait) {
    // 检查参数是否存在
    if (!func || !times || !wait) {
        return function () { };
    }
    // 检查参数类型
    if (!checkType(func, [&#39;function&#39;]) &amp;&amp; !checkType(times, [&#39;Number&#39;, &#39;String&#39;]) &amp;&amp; !checkType(wait, [&#39;Number&#39;, &#39;String&#39;])) {
        return function () { };
    }
    // 进行不规则类型的类型转换
    times = exchange(times, &#39;Number&#39;);
    wait = exchange(wait, &#39;Number&#39;);
    let i = 0;

    // 返回函数主体
    function repeat() {
        // 如果次数达到则退出
        if (times === i) {
            return;
        }
        const _args = arguments;

        func(_args[0]);
        i++;

        // 尾递归
        return setTimeout(repeat.bind(this, _args[0]), wait);
    }

    return repeat;
}
</code></pre><p>写到这里，突然觉得这个函数其实还是不够健壮。我们来分析一下参数，func参数，默认是一个函数。times参数，默认是一个非负数。wait也默认是一个非负数。</p>
<p>如果传入的参数times是一个负数，那么这个函数将会陷入死循环。这里做检测是否存在过度优化的问题？我还是抱有疑虑。</p>
<blockquote>
<p>Q: 这里如果有多个参数怎么办？比如传入的函数叫console.log,可以接受多个参数<br></p>
<p> A:方法比较多，比如可以规定传参的格式，用数组将参数包裹起来，或者使用arguments<br></p>
<p> Q: show me the code</p>
</blockquote>
<p>这里实际上有个坑，就是IE9的setTimeout只能传入两个参数（IE的梗已经被玩烂了）,这里可以使用<code>bind</code>函数来解决这个问题。</p>
<pre><code>function doRepeat(func, times, wait) {
    // 检查参数是否存在
    if (!func || !times || !wait) {
        return function () { };
    }
    // 检查参数类型
    if (!checkType(func, [&#39;function&#39;]) &amp;&amp; !checkType(times, [&#39;Number&#39;, &#39;String&#39;]) &amp;&amp; !checkType(wait, [&#39;Number&#39;, &#39;String&#39;])) {
        return function () { };
    }
    // 进行不规则类型的类型转换
    times = exchange(times, &#39;Number&#39;);
    wait = exchange(wait, &#39;Number&#39;);
    let i = 0;

    // 返回函数主体
    function repeat() {
        // 如果次数达到则退出
        if (times === i) {
            return;
        }
        const _args = [].slice.call(arguments);

        // 如果次数大于0并且是第一次执行则先执行一遍，避免setTimeout延迟问题
        func(..._args)
        // 尾递归
        return setTimeout(repeat.bind(this, _args), wait);
    }

    return repeat;
}
</code></pre><p>这里同样解释一下这行代码的作用</p>
<pre><code>const _args = [].slice.call(arguments);
</code></pre><p>可以看到我在下面的代码中使用了展开运算符<code>...</code>，但是展开运算符的使用需要迭代器。<code>arguments</code>不是数组，所以没有迭代器。</p>
<p>考虑以下代码：</p>
<pre><code>(function(){
  console.log([] instanceof Array);
})() // true

(function(){
  console.log(arguments instanceof Array);
})() // false
</code></pre><p>这些大概就是全部的面试过程，不过最后俺没去成小米，因为时间实在是不合适……</p>
<p>最后想给自己挖个坑，也出个升级版的问题</p>
<blockquote>
<p>Q: 请将这道题用setTimeout配合Generator函数实现一遍</p>
</blockquote>
<p>这几天考试，等考完试我再来填……</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-05-06</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,//edencao.github.io/blog/2019/05/06/Remember-A-Millet-Front-End-Test/,Eden's Blog,记一次小米前端面试题,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/blog/2019/05/06/Software-Process-And-Project-Management-(iv)/" title="软件过程与项目管理(四)">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/blog/2019/05/06/Operating-System-(I)/" title="操作系统（一）">下一篇</a></li></ul></div><div id="comments"></div><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var styleElm = document.createElement('link');
styleElm.rel = 'stylesheet'; 
styleElm.href = 'https://imsun.github.io/gitment/style/default.css';
document.head.appendChild(styleElm)

var gitment = new Gitment({
    id: document.querySelector('.post-title').val(),
    owner: 'EdenCao',
    repo: 'blog',
    oauth: {
        client_id: '524a2ec70d9f93b7d96f',
        client_secret: '403fd7b08932eb72291927b7c5bb6e574f7aa379'
    }
});
gitment.render('comments')</script></div></div></div></div><script src="/blog/js/jquery.js"></script><script src="/blog/js/jquery-migrate-1.2.1.min.js"></script><script src="/blog/js/jquery.appear.js"></script><script src="/blog/js/highlight.pack.js"></script><script>hljs.configure({
  tabReplace: '  ',
})
hljs.initHighlightingOnLoad();</script></body></html>