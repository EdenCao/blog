<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Cao Yong,ednencaox@gmail.com"><title>从实现一个红绿灯到函数式编程 · Eden's Blog</title><meta name="description" content="我认为函数式编程的本质是把函数当作变量来使用。最近接触了React，我们可以发现在React中处处存在函数式编程的思想，我们将JSX写成一个函数的返回值，并且在render中调用她们。函数是对于过程的抽象，我们将过程抽象成一个函数，然后根据不同的场景传入不同的变量值从而得到不同的结果。而函数式编程是"><meta name="keywords" content="JavaScript,TypeScript,Linux,macOS"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/blog/css/style.css"><link rel="stylesheet" href="/blog/css/blog_basic.css"><link rel="stylesheet" href="/blog/css/font-awesome.min.css"><link rel="stylesheet" href="/blog/css/atom-one-light.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/blog/images/logo@2x.png" style="width:127px;"><h3 title><a href="/">Eden's Blog</a></h3><div class="description"><p>一些奇奇怪怪的东西</p></div></div></div><ul class="social-links"><li><a href="http://github.com/EdenCao"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="archives/">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>从实现一个红绿灯到函数式编程</a></h3></div><div class="post-content"><p>我认为函数式编程的本质是把函数当作变量来使用。最近接触了<code>React</code>，我们可以发现在<code>React</code>中处处存在函数式编程的思想，我们将<code>JSX</code>写成一个函数的返回值，并且在<code>render</code>中调用她们。函数是对于过程的抽象，我们将过程抽象成一个函数，然后根据不同的场景传入不同的变量值从而得到不同的结果。而函数式编程是对于函数的抽象，我们把函数看作是一个变量，然后根据不同的场景传入不同的函数值从而得到不同的结果。</p>
<p>我希望可以通过实现一个小的<code>demo</code>来讲清楚这件事，这个<code>demo</code>是我很久以前在某个技术网站看到的，具体的网址已经记不清楚了，鉴于小伙伴们对于我所讲的函数式编程的概念非常感兴趣，所以我将这个例子翻了出来，自己将它重新实现一遍。若是没有讲清楚或错误的地方，则是受限于我的浅薄的技术功底，并希望被指正。</p>
<h2 id="红绿灯函数"><a href="#红绿灯函数" class="headerlink" title="红绿灯函数"></a>红绿灯函数</h2><p>客户希望我们实现一个红绿灯函数，每隔1秒钟，变换一次信号，无限循环。可以使用console.log来模拟信号灯亮的过程，即在控制台打印’绿灯亮’,1s后继续打印’黄灯亮’,1s后打印’红灯亮’…无限循环</p>
<p>实现这个效果非常简单，直接上代码</p>
<pre><code>function semaphores() {
    setTimeout(()=&gt;{
        console.log(&#39;绿灯亮&#39;);
        setTimeout(() =&gt; {
            console.log(&#39;黄灯亮&#39;);
            setTimeout(() =&gt; {
                console.log(&#39;红灯亮&#39;);
                semaphores();
            }, 1000)
        }, 1000)
    },1000) 
}

// delay 1s
// 绿灯亮 
// delay 1s
// 黄灯亮
// delay 1s
// 红灯亮
// delay 1s
// ...
</code></pre><p>但是很明显，这样的函数及其不优雅，我们的红绿灯只有三种颜色，如果要是有十几种颜色的霓虹灯闪来闪去的话，我们就要嵌套十几层代码了。这样可读性实在是太差了，于是我们希望可以把它优化一下。</p>
<p>仔细分析一下我们的代码就会发现，上面的demo有非常多的冗余代码，setTimeout在一个函数中被重复使用了三次，每次只不过是一个嵌套再打印不同的红黄绿灯而已，我们为什么不把公共部分提取出来呢？把红黄绿灯提取成变量，代码质量会好很多。</p>
<p>so出现了下列的代码：</p>
<pre><code>const TRAFFIC_LIGHT = [
    &#39;绿灯&#39;,
    &#39;黄灯&#39;,
    &#39;红灯&#39;
]

function semaphores(lightList = [], count = 0) {
    // 控制器
    let lightLength = lightList.length;

    return setTimeout(() =&gt; {
        console.log(`${lightList[count % lightLength]}`);
        count ++;
        semaphores(lightList,count);
    }, 1000)
}

// delay 1s
// 绿灯亮 
// delay 1s
// 黄灯亮
// delay 1s
// 红灯亮
// delay 1s
// ...
</code></pre><p>我们还可以进一步优化，同时将时间抽离:</p>
<pre><code>const TRAFFIC_LIGHT = [
    [&#39;绿灯&#39;, 1000],
    [&#39;黄灯&#39;, 2000],
    [&#39;红灯&#39;, 3000]
]

function semaphores(lightList = [], count = 0) {
    const lightLength = lightList.length;     

    return function handleSemaphores(){
        const [light, time] = lightList[count % lightLength];

        return setTimeout(() =&gt; {
            console.log(`${light}亮`);
            count ++;
            handleSemaphores();
        }, time)
    }
}

// delay 1s
// 绿灯亮 
// delay 2s
// 黄灯亮
// delay 3s
// 红灯亮
// delay 1s
// ...
</code></pre><p>我们可以更加容易修改我们的代码，以应对将来可能的需求变更。这也是我们常见的函数形式。变量只是 Number、String、Object、undefined、null、Boolean，但是我们再次将问题变得复杂一些：</p>
<p>我们的红绿灯效果良好，客户非常满意，并且希望扩展应用范围。为了应对可能到来的困惑，我们需要在每次信号灯亮起的时候添加上一条提示语，提醒剩余时间。不同的应用场景将有不同的提示语。</p>
<p>这也非常简单，我们只需要多加一条语句就可以完成:</p>
<pre><code>const TRAFFIC_LIGHT = [
    [&#39;绿灯&#39;, 1000],
    [&#39;黄灯&#39;, 2000],
    [&#39;红灯&#39;, 3000]
]

function semaphores(lightList = [], count = 0) {
    const lightLength = lightList.length;     

    return function handleSemaphores(){
        const [light, time] = lightList[count % lightLength];

        return setTimeout(() =&gt; {
            console.log(`${light}亮`);
            // add here!!!
            console.log(&#39;这是一条提示语&#39;);
            count ++;
            handleSemaphores();
        }, time)
    }
}

// delay 1s
// 绿灯亮 
// 这是一条提示语
// delay 2s
// 黄灯亮
// 这是一条提示语
// delay 3s
// 红灯亮
// 这是一条提示语
// delay 1s
// ...
</code></pre><p>但随着我们的应用场景进一步增多，我们的红绿灯将广泛的用于医疗、运输、零售行业，对于这些行业我们需要在信号灯亮起时拥有不同的操作，有的是发出声响、有的是打印提示语、有的是发出警报、有的是打开开关…</p>
<p>那么我们是不是需要把上面的那份代码到处拷贝一下，然后修改位于16行的代码，分别把它修改为发声、打印、报警、开关控制…</p>
<p>显然一般的函数已经无法满足我们的需求了，这时候我们就需要函数式编程。</p>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>我上面只是为了引出函数式编程的例子，所以举例夸张了一些。事实上函数式编程并不是非常高大上的概念，它就和面向对象、面向过程一样，只是一种编程的范式，在实际中拥有着非常广泛的应用（例如JSX）</p>
<p>就像我一开始提到的那样，函数式编程的核心不过是将函数当作变量那样来使用。我们希望改造一下我们的红绿灯函数，使我们的函数在信号灯亮后，可以在不同的场景使用不同的参数，我们来设计一下这个函数.首先我们需要传入一个函数，所以我们在形参列表中加入一个<code>handler</code>的变量，便于我们使用它。然后在我们希望使用它的地方使用就好了。</p>
<pre><code>const TRAFFIC_LIGHT = [
    [&#39;绿灯&#39;, 1000],
    [&#39;黄灯&#39;, 2000],
    [&#39;红灯&#39;, 3000]
]

// 请注意我们在这里加入了一个参数handler
function semaphores(lightList = [], handler, count = 0) {
    const lightLength = lightList.length;     

    return function handleSemaphores(){
        const [light, time] = lightList[count % lightLength];

        return setTimeout(() =&gt; {
            console.log(`${light}亮`);
            // 在这里使用它
            handler &amp;&amp; handler(light, time);
            count ++;
            handleSemaphores();
        }, time)
    }
}
</code></pre><p>我们可以这样使用上面的函数:</p>
<pre><code>// 我们只需要在不同的场景改变不同的handler就可以了
const handler = function (light, time) {
    console.log(&#39;函数式编程好爽啊&#39;);
    console.log(`${light}亮${time}毫秒~~`)
}

const doTrafficLight = semaphores(TRAFFIC_LIGHT, handler);
const trafficTimeHandler = doTrafficLight();
// delay 1s
// 绿灯亮
// 函数式编程好爽啊
// 绿灯亮1000毫秒~~
// delay 2s
// 黄灯亮
// 函数式编程好爽啊
// 黄灯亮2000毫秒~~
// delay 3s
// 红灯亮
// 函数式编程好爽啊
// 红灯亮3000毫秒~~
// ...
</code></pre><p>我们更可以优化一下上面的函数，使得不同等亮起时使用不同的行为函数:</p>
<pre><code>const TRAFFIC_LIGHT = [
    [&#39;绿灯&#39;, 1000, function() {
     // do something...
    }],
    [&#39;黄灯&#39;, 2000, function() {
     // do something...
    }],
    [&#39;红灯&#39;, 3000, function() {
     // do something...
    }]
]

// 我们去掉了handler!!!!
function semaphores(lightList = [], count = 0) {
    const lightLength = lightList.length;     

    return function handleSemaphores(){
        const [light, time, handler] = lightList[count % lightLength];

        return setTimeout(() =&gt; {
            console.log(`${light}亮`);
            // 在这里使用它
            handler &amp;&amp; handler(light, time);
            count ++;
            handleSemaphores();
        }, time)
    }
}

// delay 1s
// 绿灯亮
// dosomething1...
// delay 2s
// 黄灯亮
// dosomething2...
// delay 3s
// 红灯亮
// dosomething3...
// ...
</code></pre><p>函数式编程的抽象程度更高，它是对于过程的抽象。如果没有传入的参数作为支撑，那么这个函数毫无意义，比较明显的例子是<code>JavaScript</code>中的<code>map</code>和<code>reduce</code>。这是最主要的概念，剩下的概念则都是一些规定，帮助我们写出更好的更健壮的函数式函数，相信理解了我刚刚所说的例子，再去理解其他概念会容易许多。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-05-06</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,//edencao.github.io/blog/2019/05/06/From-Implementing-A-Traffic-Light-To-Functional-Programming/,Eden's Blog,从实现一个红绿灯到函数式编程,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/blog/2019/05/06/Draft.js-Event-Handling-Mechanism/" title="Draft.js的事件处理机制">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/blog/2019/05/06/Event-Dilutes-Debounce-&amp;-Throttle/" title="事件稀释 Debounce &amp; Throttle">下一篇</a></li></ul></div><div id="comments"></div><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var styleElm = document.createElement('link');
styleElm.rel = 'stylesheet'; 
styleElm.href = 'https://imsun.github.io/gitment/style/default.css';
document.head.appendChild(styleElm)

var gitment = new Gitment({
    id: document.querySelector('.post-title').textContent.split(' ').join('_'),
    owner: 'EdenCao',
    repo: 'blog',
    oauth: {
        client_id: '524a2ec70d9f93b7d96f',
        client_secret: '403fd7b08932eb72291927b7c5bb6e574f7aa379'
    }
});
gitment.render('comments')</script></div></div></div></div><script src="/blog/js/jquery.js"></script><script src="/blog/js/jquery-migrate-1.2.1.min.js"></script><script src="/blog/js/jquery.appear.js"></script><script src="/blog/js/highlight.pack.js"></script><script>hljs.configure({
  tabReplace: '  ',
})
hljs.initHighlightingOnLoad();</script></body></html>