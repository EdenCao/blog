<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Eden Cao"><title>Draft.js的事件处理机制 · Eden's Blog</title><meta name="description" content="Draft 事件处理机制Draft.js 内部封装了一系列基础的事件处理函数，当事件触发时，这些函数接收当前event，并基于此生成new editorState，我们在接收到new editorState后再将该数据绑定到Draft上，这就是Draft的单向数据流。其中react层只负责视图层，我"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/blog/css/style.css"><link rel="stylesheet" href="/blog/css/blog_basic.css"><link rel="stylesheet" href="/blog/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/blog/images/logo@2x.png" style="width:127px;"><h3 title><a href="/">Eden's Blog</a></h3><div class="description"><p>一些奇奇怪怪的东西</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/archives">Arquivo</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Draft.js的事件处理机制</a></h3></div><div class="post-content"><h1 id="Draft-事件处理机制"><a href="#Draft-事件处理机制" class="headerlink" title="Draft 事件处理机制"></a>Draft 事件处理机制</h1><p>Draft.js 内部封装了一系列基础的事件处理函数，当事件触发时，这些函数接收当前<code>event</code>，并基于此生成<code>new editorState</code>，我们在接收到<code>new editorState</code>后再将该数据绑定到<code>Draft</code>上，这就是Draft的单向数据流。其中<code>react</code>层只负责视图层，我们将通过一些流程图与源码的展示来详细介绍这一点。</p>
<h2 id="事件在-Draft-内部的传递"><a href="#事件在-Draft-内部的传递" class="headerlink" title="事件在 Draft 内部的传递"></a>事件在 Draft 内部的传递</h2><div class="image-package"><div class="image-container" style="max-width: 700px; max-height: 577px;"><div class="image-container-fill" style="padding-bottom: 82.45%;"></div><div class="image-view" data-width="1094" data-height="902"><img data-original-src="//upload-images.jianshu.io/upload_images/5617469-b27a9ec7b9eff1a5.png" data-original-width="1094" data-original-height="902" data-original-format="image/png" data-original-filesize="71922"></div></div><div class="image-caption">eventInDraft.png</div></div>

<p><code>Draft</code> 由事件驱动，任何事件的触发最终都会被转化为一个新的<code>EditorState</code>。上图是一个简单的流程图，展现了事件在 Draft 内部的传递机制。</p>
<p><code>react</code>只负责事件的绑定与<code>view</code>的展示，将<code>Draft</code>中内置的事件<code>editorBlur</code>等方法与原生事件<code>blur</code>进行绑定，下面给出了<code>Draft</code>源码进行说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// DraftEditor.react.js</span><br><span class="line"></span><br><span class="line">// 经过精简</span><br><span class="line">render() &#123;</span><br><span class="line">    &lt;div</span><br><span class="line">        // 将原生事件与Draft内置事件相绑定</span><br><span class="line">        onBeforeInput=&#123;this._onBeforeInput&#125;</span><br><span class="line">        onBlur=&#123;this._onBlur&#125;</span><br><span class="line">        onCopy=&#123;this._onCopy&#125;</span><br><span class="line">        onCut=&#123;this._onCut&#125;</span><br><span class="line">        onDragEnd=&#123;this._onDragEnd&#125;</span><br><span class="line">        onDragEnter=&#123;this.onDragEnter&#125;</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        // 请暂时忽略下面这部分</span><br><span class="line">        &lt;DraftEditorContents &#123;...editorContentsProps&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码部分我们可以看到，react将原生事件与内置事件做了绑定，例如将<code>_onBlur</code>绑定到了原生事件<code>onBlur</code>上面。而_onBlur内部的事件则被单独抽象出来，与视图层完全解耦。</p>
<p><code>Draft</code>运用了一些很酷的小技巧来解决内置事件与原生事件的绑定问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 经过精简</span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123;onBlur, onCopy, onFocus&#125; from &apos;./logicLayer&apos;;</span><br><span class="line"></span><br><span class="line">const handler = &#123;</span><br><span class="line">  onBlur(e) &#123;</span><br><span class="line">    editOnBlur(e);</span><br><span class="line">  &#125;</span><br><span class="line">  onCopy(e) &#123;</span><br><span class="line">    editOnCopy(e);</span><br><span class="line">  &#125;</span><br><span class="line">  onFocus(e) &#123;</span><br><span class="line">    editonFocus(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DraftEditor extends Component &#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">    </span><br><span class="line">    // 事件绑定</span><br><span class="line">    this._onBlur = this._buildHandler(&apos;onBlur&apos;);</span><br><span class="line">    this._onCopy = this._buildHandler(&apos;onCopy&apos;);</span><br><span class="line">    this._onCut = this._buildHandler(&apos;onCut&apos;);</span><br><span class="line">    this._onInput = this._buildHandler(&apos;onInput&apos;);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  _buildHandler(eventName) &#123;</span><br><span class="line">    return e =&gt; &#123;</span><br><span class="line">      const method = this._handler &amp;&amp; this.handler[eventName];</span><br><span class="line">      method &amp;&amp; method(this, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心函数是<code>_buildHandler</code>,通过此函数进行事件绑定的分发。</p>
<p>通过这种方式，可以完成视图层与逻辑层的解耦。</p>
<p>任何事件的触发最后都会被转化为一个<code>new EditorState</code>,通过onChange（update）方法抛出，我们接收到<code>new EditorState</code>后，再将其绑定到<code>Draft</code>上面，由<code>Draft</code>负责<code>EditorState</code>的转换，最终通过react渲染出来。</p>
<p>也就是说，任何<code>new EditorState</code>都一定会被<code>Draft</code>抛给我们，再由我们绑定到<code>Draft</code>上面进行展示，<code>EditorState</code>不是一个内部状态。</p>
<p>当然<code>Draft</code>对EditorState进行转换的过程远远没有这么简单，实际情况要复杂的多，这点我们将会在下面提到。</p>
<p>通过上面所提到的这种方式，<code>Draft</code>完成了由事件到状态对象的转化，并且完成了数据的单向流动。</p>
<h2 id="Draft-事件层和展示层的分离"><a href="#Draft-事件层和展示层的分离" class="headerlink" title="Draft 事件层和展示层的分离"></a>Draft 事件层和展示层的分离</h2><div class="image-package"><div class="image-container" style="max-width: 700px; max-height: 955px;"><div class="image-container-fill" style="padding-bottom: 136.47%;"></div><div class="image-view" data-width="998" data-height="1362"><img data-original-src="//upload-images.jianshu.io/upload_images/5617469-6125572d566da98e.png" data-original-width="998" data-original-height="1362" data-original-format="image/png" data-original-filesize="50076"></div></div><div class="image-caption">Event&amp;View.png</div></div>

<p>我在上面大致画出了<code>draft</code>的<code>react</code>层是如何划分的。其实这个图并不准确，但是用来说明已经够用了。</p>
<p>在<code>react</code>层将事件绑定层与实践展示层分离：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// DraftEditor.react.js</span><br><span class="line">// 经过精简</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Event层</span><br><span class="line"> */</span><br><span class="line">render() &#123;</span><br><span class="line">    &lt;div</span><br><span class="line">        // 将原生事件与Draft内置事件相绑定</span><br><span class="line">        onBeforeInput=&#123;this._onBeforeInput&#125;</span><br><span class="line">        onBlur=&#123;this._onBlur&#125;</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        /**</span><br><span class="line">         * View 层</span><br><span class="line">         */</span><br><span class="line">        &lt;DraftEditorContents &#123;...editorContentsProps&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>仔细查看上面的代码，依旧是相同的<code>render</code>函数，这次我将事件绑定的部分隐去了大部分，主要可以看到在这个组件中引入了<code>DraftEditorContents</code>组件，这个组件就是事件的展示层。在此层中，储存了<code>preEditorStatus</code>,<code>View</code>层负责将<code>diff</code>过后的<code>latestEditorStatus</code>渲染出来。</p>
<p>中间会经过一些过程，在此期间<code>Draft</code>会向外暴露一些端口用于处理类似于<code>block</code>样式与<code>inline</code>样式，具体内容会在扩展中提及。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-05-01</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,//edencao.github.io/blog/2019/05/01/Draftjs-Event-Processing/,Eden's Blog,Draft.js的事件处理机制,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/blog/2019/05/01/Rem-And-VW/" title="谈谈 rem 与 vw -- rem">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/blog/2019/05/01/Hello-FP/" title="从实现一个红绿灯到函数式编程">Próximo post</a></li></ul></div></div></div></div></div><script src="/blog/js/jquery.js"></script><script src="/blog/js/jquery-migrate-1.2.1.min.js"></script><script src="/blog/js/jquery.appear.js"></script><script src="/blog/js/jianshu-image-fixer.js"></script></body></html>