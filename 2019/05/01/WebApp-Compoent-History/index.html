<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Eden Cao"><title>前端组件化之路的一些思考与被神化的MVVM · Eden's Blog</title><meta name="description" content="当初上手使用的时候就直接使用的 Vue，简单方便且直接。但最近在思考为什么三大框架得以挤掉 jQuery 变得流行，至于流行的原因众说纷纭，但我认为真正的原因只有两个：

提供一种简单方便的开发范式，你不需要知道框架的运行原理就可以快速方便的开发出一个网站
第二个原因则是最重要的：因为数据和 DOM"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title><a href="/">Eden's Blog</a></h3><div class="description"><p>一些奇奇怪怪的东西</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>前端组件化之路的一些思考与被神化的MVVM</a></h3></div><div class="post-content"><p>当初上手使用的时候就直接使用的 Vue，简单方便且直接。但最近在思考为什么三大框架得以挤掉 jQuery 变得流行，至于流行的原因众说纷纭，但我认为真正的原因只有两个：</p>
<ul>
<li>提供一种简单方便的开发范式，你不需要知道框架的运行原理就可以快速方便的开发出一个网站</li>
<li>第二个原因则是最重要的：因为数据和 DOM 的同步并不简单。</li>
</ul>
<!-- -->
<h2 id="简单方便的开发范式"><a href="#简单方便的开发范式" class="headerlink" title="简单方便的开发范式"></a>简单方便的开发范式</h2><p>先说第一个：无论是 Vue、React还是Angular实际上都默认提供了一种简单方便并且可维护的项目组织结构方式：组件。</p>
<p>无论是 Vue的单文件组件还是 React 的tsx都鼓励将一个完整的网站、页面的不同组成部分拆分成一个组件，再像搭积木一样将它们拼接起来。这样所构建的网站可维护性良好、更容易构建出来超大规模项目 — — 超过数十万行代码的 js 项目。<br></p>
<p> 你再也不需要使用类似于jQuery一样类似于意大利面条一样的开发方式了。当然，事实上在 MVVM 框架出现之前有各种各样的方法将项目拆分，但的确很少有像 jsx 一样优雅的项目组织方式了。<br></p>
<p> 万幸我没有经历过那样一个时代。</p>
<h2 id="数据与-DOM-的同步问题"><a href="#数据与-DOM-的同步问题" class="headerlink" title="数据与 DOM 的同步问题"></a>数据与 DOM 的同步问题</h2><p>JavaScript 的主要运行环境之一是浏览器，其责任是负责视图的渲染与用户的交互。随着前端页面的复杂程度的增长，js 必须承担起更大的责任。数据的改变与DOM的同步问题变成了一个非常头痛的问题。</p>
<p>这里我想做一个简单的todo-list来说明这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">class Todo &#123;</span><br><span class="line">      constructor(msg) &#123;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">        this.dom = null;</span><br><span class="line"></span><br><span class="line">        this.createTodoItem();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      createTodoItem() &#123;</span><br><span class="line">        const todo = document.createElement(&apos;div&apos;);</span><br><span class="line">        todo.innerText = this.msg;</span><br><span class="line">        this.dom = todo;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      remove() &#123;</span><br><span class="line">        this.dom.remove();</span><br><span class="line">        this.dom = null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      destroy() &#123;</span><br><span class="line">        this.remove();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Diff &#123;</span><br><span class="line">      constructor(option, index, data) &#123;</span><br><span class="line">        this.op = option;</span><br><span class="line">        this.index = index;</span><br><span class="line">        this.data = data;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class TodoWrapper &#123;</span><br><span class="line">      constructor(wrapper) &#123;</span><br><span class="line">        if (typeof wrapper === &apos;string&apos;) &#123;</span><br><span class="line">          wrapper = document.querySelector(wrapper);</span><br><span class="line">        &#125;</span><br><span class="line">        this.wrapper = wrapper;</span><br><span class="line">        this.container = null;</span><br><span class="line">        this.todos = [];</span><br><span class="line">        this.todoDoms = [];</span><br><span class="line"></span><br><span class="line">        this.createContainer();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      render(diff) &#123;</span><br><span class="line">        switch (diff.op) &#123;</span><br><span class="line">          case &apos;add&apos;:</span><br><span class="line">            this.addTodoItemDom(diff.index, diff.data);</span><br><span class="line">            break;</span><br><span class="line">          case &apos;remove&apos;:</span><br><span class="line">            this.removeTodoItemDom(diff.index, diff.data);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      addTodoItemDom(index, todo) &#123;</span><br><span class="line">        const sibling = this.todoDoms[index];</span><br><span class="line">        if (this.todoDoms.indexOf(todo) &gt;= 0) &#123;</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!sibling) &#123;</span><br><span class="line">          this.container.appendChild(todo.dom);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.container.insertBefore(todo.dom, sibling);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      removeTodoItemDom(index) &#123;</span><br><span class="line">        const todo = this.todoDoms[index];</span><br><span class="line">        todo.remove();</span><br><span class="line">        this.todoDoms.splice(index, 1);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      addTodoItem(index, todo) &#123;</span><br><span class="line">        if (this.todos.indexOf(todo) &gt;= 0) &#123;</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        this.todos.splice(index, 0, todo);</span><br><span class="line">        const diff = new Diff(&apos;add&apos;, index, todo);</span><br><span class="line">        this.render(diff);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      removeTodoItem(index, todo) &#123;</span><br><span class="line">        if (this.todos.indexOf(todo) &gt;= 0) &#123;</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        this.todos.splice(index, 1, todo);</span><br><span class="line">        const diff = new Diff(&apos;remove&apos;, index, todo);</span><br><span class="line">        this.render(diff);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      createContainer() &#123;</span><br><span class="line">        const container = document.createElement(&apos;div&apos;);</span><br><span class="line">        container.classList.add(&apos;todo-container&apos;);</span><br><span class="line">        this.wrapper.appendChild(container);</span><br><span class="line">        this.container = container;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      destroy() &#123;</span><br><span class="line">        this.wrapper = null;</span><br><span class="line">        this.container = null;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如此复杂的操作也是MVVM出现的原因。我们不需要再关注 DOM 的同步问题，只需要关注数据的改变即可。当数据改变的时候，我们的视图会随之变化。</p>
<p>用Vue举例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// in .vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;todo-wrapper&quot;&gt;</span><br><span class="line">    &lt;template v-for=&quot;todo in todoList&quot;&gt;</span><br><span class="line">      &lt;Todo :msg=&quot;todo.msg&quot; /&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default Vue.extend(&#123;</span><br><span class="line">  name: &apos;todoList&apos;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Todo,</span><br><span class="line">  &#125;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      todoList: [],</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>是不是简单多了？</p>
<p>三大框架的流行使得现在出现很多脱离了框架就不会进行网站开发的“偏科生”</p>
<p>之前有一篇特别有名的文章 <a href="https://github.com/xufei/blog/issues/19" target="_blank" rel="noopener">2015前端组件化框架之路 · Issue #19 · xufei/blog · GitHub</a> 推荐在学习框架的同时读一读，大概可以理解在15年那个分叉路口的风起云涌，也大致能理解为什么现在三大框架三足鼎立。</p>
<p>有些框架被历史放弃，有些则激流勇进。</p>
<h2 id="被神化的MVVM"><a href="#被神化的MVVM" class="headerlink" title="被神化的MVVM"></a>被神化的MVVM</h2><p>不久之前 Vue 在 github 的 star 数量超过了 react。但其实随着我接触前段时间的增长，我发现我更加喜欢 react 的开发方式，即使我最先接触的是 Vue。</p>
<p>用于比较 Vue 与 React 区别的文章有很多，我在这里只想谈谈我自己的使用感受。</p>
<p>就使用方式而言，Vue 是传一个配置文件给构造函数，而 React 则是配合 babel 的 jsx 转换自己写一个组件的类。</p>
<p>ES6提供了标准的 Class，这让构建一个 React 组件时继承方式变得简单，当然，Vue 也提供了自己的 mixin 方式来实现，但总觉得有些别扭。</p>
<p>当然，我并不是说Vue不好。</p>
<p>什么是 MVVM 呢？</p>
<p>就我自己而言的理解来说，数据驱动，使开发人员的关注点从视图分离，不需要注重数据与视图同步的过程。</p>
<p>就实现方式而言，Vue通过es5所提供的 getter 和 setter 方法来实现依赖手机与视图更新，而React 则是通过手动触发。</p>
<p>就效果而言，Vue的实现方式可以实现精准dom更新（因为Vue是深度绑定，如果是数组则会遍历整个数组使其响应化），而React则因为使用了数据更新的浅拷贝换取性能优势。</p>
<p>这里仅以 Vue 为例</p>
<p>相信对于 Vue 有一定了解的人都听说过 Watcher， Vue 实际上是使用观察者模式来实现 MVVM（不是发布订阅模式）</p>
<p>在Vue初始化的时候实际上会进行一次渲染以触发数据的getter进行依赖收集。由于依赖收集与视图的更新依赖于getter/setter，为了达到这个目的，Vue需要深度遍历Data的每一个属性使其响应化（深度遍历每一个属性为其绑定上getter/setter，如果是数组，则会遍历整个数组）。</p>
<p>当页面的变量达到非常大的时候，对于性能的需求与内存的需求都是一个不小的数字。</p>
<p>我没有深入研究过React，不过相信过程都是差不多的，都需要进行依赖收集。</p>
<p>MVVM的确是前端工程化的利器，但还是需要用客观的思想去看待问题，有时候自己瞎想，当工程规模更大的时候、更大的时候、更大的时候，MVVM 或许就会成为限制前端发展的瓶颈。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-05-01</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,//edencao.github.io/blog/2019/05/01/WebApp-Compoent-History/,Eden's Blog,前端组件化之路的一些思考与被神化的MVVM,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2019/05/01/Watcher-and-DepWithSub/" title="观察者模式 vs 订阅发布模式">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/05/01/About-JS-Inheritance/" title="关于 ES Class 继承中的二三事（一）(你知道的原型链下)">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/jianshu-image-fixer.js"></script></body></html>